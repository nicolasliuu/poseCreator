{"ast":null,"code":"import { AmbientLight, AnimationClip, Bone, BufferGeometry, ClampToEdgeWrapping, Color, DirectionalLight, DoubleSide, FileLoader, Float32BufferAttribute, FrontSide, Group, Line, LineBasicMaterial, LineSegments, Loader, LoaderUtils, MathUtils, Matrix4, Mesh, MeshBasicMaterial, MeshLambertMaterial, MeshPhongMaterial, OrthographicCamera, PerspectiveCamera, PointLight, Quaternion, QuaternionKeyframeTrack, RepeatWrapping, Scene, Skeleton, SkinnedMesh, SpotLight, TextureLoader, Vector2, Vector3, VectorKeyframeTrack, sRGBEncoding } from 'three';\nimport { TGALoader } from '../loaders/TGALoader.js';\nclass ColladaLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text, path));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(text, path) {\n    function getElementsByTagName(xml, name) {\n      // Non recursive xml.getElementsByTagName() ...\n\n      const array = [];\n      const childNodes = xml.childNodes;\n      for (let i = 0, l = childNodes.length; i < l; i++) {\n        const child = childNodes[i];\n        if (child.nodeName === name) {\n          array.push(child);\n        }\n      }\n      return array;\n    }\n    function parseStrings(text) {\n      if (text.length === 0) return [];\n      const parts = text.trim().split(/\\s+/);\n      const array = new Array(parts.length);\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parts[i];\n      }\n      return array;\n    }\n    function parseFloats(text) {\n      if (text.length === 0) return [];\n      const parts = text.trim().split(/\\s+/);\n      const array = new Array(parts.length);\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parseFloat(parts[i]);\n      }\n      return array;\n    }\n    function parseInts(text) {\n      if (text.length === 0) return [];\n      const parts = text.trim().split(/\\s+/);\n      const array = new Array(parts.length);\n      for (let i = 0, l = parts.length; i < l; i++) {\n        array[i] = parseInt(parts[i]);\n      }\n      return array;\n    }\n    function parseId(text) {\n      return text.substring(1);\n    }\n    function generateId() {\n      return 'three_default_' + count++;\n    }\n    function isEmpty(object) {\n      return Object.keys(object).length === 0;\n    }\n\n    // asset\n\n    function parseAsset(xml) {\n      return {\n        unit: parseAssetUnit(getElementsByTagName(xml, 'unit')[0]),\n        upAxis: parseAssetUpAxis(getElementsByTagName(xml, 'up_axis')[0])\n      };\n    }\n    function parseAssetUnit(xml) {\n      if (xml !== undefined && xml.hasAttribute('meter') === true) {\n        return parseFloat(xml.getAttribute('meter'));\n      } else {\n        return 1; // default 1 meter\n      }\n    }\n\n    function parseAssetUpAxis(xml) {\n      return xml !== undefined ? xml.textContent : 'Y_UP';\n    }\n\n    // library\n\n    function parseLibrary(xml, libraryName, nodeName, parser) {\n      const library = getElementsByTagName(xml, libraryName)[0];\n      if (library !== undefined) {\n        const elements = getElementsByTagName(library, nodeName);\n        for (let i = 0; i < elements.length; i++) {\n          parser(elements[i]);\n        }\n      }\n    }\n    function buildLibrary(data, builder) {\n      for (const name in data) {\n        const object = data[name];\n        object.build = builder(data[name]);\n      }\n    }\n\n    // get\n\n    function getBuild(data, builder) {\n      if (data.build !== undefined) return data.build;\n      data.build = builder(data);\n      return data.build;\n    }\n\n    // animation\n\n    function parseAnimation(xml) {\n      const data = {\n        sources: {},\n        samplers: {},\n        channels: {}\n      };\n      let hasChildren = false;\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        let id;\n        switch (child.nodeName) {\n          case 'source':\n            id = child.getAttribute('id');\n            data.sources[id] = parseSource(child);\n            break;\n          case 'sampler':\n            id = child.getAttribute('id');\n            data.samplers[id] = parseAnimationSampler(child);\n            break;\n          case 'channel':\n            id = child.getAttribute('target');\n            data.channels[id] = parseAnimationChannel(child);\n            break;\n          case 'animation':\n            // hierarchy of related animations\n            parseAnimation(child);\n            hasChildren = true;\n            break;\n          default:\n            console.log(child);\n        }\n      }\n      if (hasChildren === false) {\n        // since 'id' attributes can be optional, it's necessary to generate a UUID for unqiue assignment\n\n        library.animations[xml.getAttribute('id') || MathUtils.generateUUID()] = data;\n      }\n    }\n    function parseAnimationSampler(xml) {\n      const data = {\n        inputs: {}\n      };\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'input':\n            const id = parseId(child.getAttribute('source'));\n            const semantic = child.getAttribute('semantic');\n            data.inputs[semantic] = id;\n            break;\n        }\n      }\n      return data;\n    }\n    function parseAnimationChannel(xml) {\n      const data = {};\n      const target = xml.getAttribute('target');\n\n      // parsing SID Addressing Syntax\n\n      let parts = target.split('/');\n      const id = parts.shift();\n      let sid = parts.shift();\n\n      // check selection syntax\n\n      const arraySyntax = sid.indexOf('(') !== -1;\n      const memberSyntax = sid.indexOf('.') !== -1;\n      if (memberSyntax) {\n        //  member selection access\n\n        parts = sid.split('.');\n        sid = parts.shift();\n        data.member = parts.shift();\n      } else if (arraySyntax) {\n        // array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.\n\n        const indices = sid.split('(');\n        sid = indices.shift();\n        for (let i = 0; i < indices.length; i++) {\n          indices[i] = parseInt(indices[i].replace(/\\)/, ''));\n        }\n        data.indices = indices;\n      }\n      data.id = id;\n      data.sid = sid;\n      data.arraySyntax = arraySyntax;\n      data.memberSyntax = memberSyntax;\n      data.sampler = parseId(xml.getAttribute('source'));\n      return data;\n    }\n    function buildAnimation(data) {\n      const tracks = [];\n      const channels = data.channels;\n      const samplers = data.samplers;\n      const sources = data.sources;\n      for (const target in channels) {\n        if (channels.hasOwnProperty(target)) {\n          const channel = channels[target];\n          const sampler = samplers[channel.sampler];\n          const inputId = sampler.inputs.INPUT;\n          const outputId = sampler.inputs.OUTPUT;\n          const inputSource = sources[inputId];\n          const outputSource = sources[outputId];\n          const animation = buildAnimationChannel(channel, inputSource, outputSource);\n          createKeyframeTracks(animation, tracks);\n        }\n      }\n      return tracks;\n    }\n    function getAnimation(id) {\n      return getBuild(library.animations[id], buildAnimation);\n    }\n    function buildAnimationChannel(channel, inputSource, outputSource) {\n      const node = library.nodes[channel.id];\n      const object3D = getNode(node.id);\n      const transform = node.transforms[channel.sid];\n      const defaultMatrix = node.matrix.clone().transpose();\n      let time, stride;\n      let i, il, j, jl;\n      const data = {};\n\n      // the collada spec allows the animation of data in various ways.\n      // depending on the transform type (matrix, translate, rotate, scale), we execute different logic\n\n      switch (transform) {\n        case 'matrix':\n          for (i = 0, il = inputSource.array.length; i < il; i++) {\n            time = inputSource.array[i];\n            stride = i * outputSource.stride;\n            if (data[time] === undefined) data[time] = {};\n            if (channel.arraySyntax === true) {\n              const value = outputSource.array[stride];\n              const index = channel.indices[0] + 4 * channel.indices[1];\n              data[time][index] = value;\n            } else {\n              for (j = 0, jl = outputSource.stride; j < jl; j++) {\n                data[time][j] = outputSource.array[stride + j];\n              }\n            }\n          }\n          break;\n        case 'translate':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n        case 'rotate':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n        case 'scale':\n          console.warn('THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform);\n          break;\n      }\n      const keyframes = prepareAnimationData(data, defaultMatrix);\n      const animation = {\n        name: object3D.uuid,\n        keyframes: keyframes\n      };\n      return animation;\n    }\n    function prepareAnimationData(data, defaultMatrix) {\n      const keyframes = [];\n\n      // transfer data into a sortable array\n\n      for (const time in data) {\n        keyframes.push({\n          time: parseFloat(time),\n          value: data[time]\n        });\n      }\n\n      // ensure keyframes are sorted by time\n\n      keyframes.sort(ascending);\n\n      // now we clean up all animation data, so we can use them for keyframe tracks\n\n      for (let i = 0; i < 16; i++) {\n        transformAnimationData(keyframes, i, defaultMatrix.elements[i]);\n      }\n      return keyframes;\n\n      // array sort function\n\n      function ascending(a, b) {\n        return a.time - b.time;\n      }\n    }\n    const position = new Vector3();\n    const scale = new Vector3();\n    const quaternion = new Quaternion();\n    function createKeyframeTracks(animation, tracks) {\n      const keyframes = animation.keyframes;\n      const name = animation.name;\n      const times = [];\n      const positionData = [];\n      const quaternionData = [];\n      const scaleData = [];\n      for (let i = 0, l = keyframes.length; i < l; i++) {\n        const keyframe = keyframes[i];\n        const time = keyframe.time;\n        const value = keyframe.value;\n        matrix.fromArray(value).transpose();\n        matrix.decompose(position, quaternion, scale);\n        times.push(time);\n        positionData.push(position.x, position.y, position.z);\n        quaternionData.push(quaternion.x, quaternion.y, quaternion.z, quaternion.w);\n        scaleData.push(scale.x, scale.y, scale.z);\n      }\n      if (positionData.length > 0) tracks.push(new VectorKeyframeTrack(name + '.position', times, positionData));\n      if (quaternionData.length > 0) tracks.push(new QuaternionKeyframeTrack(name + '.quaternion', times, quaternionData));\n      if (scaleData.length > 0) tracks.push(new VectorKeyframeTrack(name + '.scale', times, scaleData));\n      return tracks;\n    }\n    function transformAnimationData(keyframes, property, defaultValue) {\n      let keyframe;\n      let empty = true;\n      let i, l;\n\n      // check, if values of a property are missing in our keyframes\n\n      for (i = 0, l = keyframes.length; i < l; i++) {\n        keyframe = keyframes[i];\n        if (keyframe.value[property] === undefined) {\n          keyframe.value[property] = null; // mark as missing\n        } else {\n          empty = false;\n        }\n      }\n      if (empty === true) {\n        // no values at all, so we set a default value\n\n        for (i = 0, l = keyframes.length; i < l; i++) {\n          keyframe = keyframes[i];\n          keyframe.value[property] = defaultValue;\n        }\n      } else {\n        // filling gaps\n\n        createMissingKeyframes(keyframes, property);\n      }\n    }\n    function createMissingKeyframes(keyframes, property) {\n      let prev, next;\n      for (let i = 0, l = keyframes.length; i < l; i++) {\n        const keyframe = keyframes[i];\n        if (keyframe.value[property] === null) {\n          prev = getPrev(keyframes, i, property);\n          next = getNext(keyframes, i, property);\n          if (prev === null) {\n            keyframe.value[property] = next.value[property];\n            continue;\n          }\n          if (next === null) {\n            keyframe.value[property] = prev.value[property];\n            continue;\n          }\n          interpolate(keyframe, prev, next, property);\n        }\n      }\n    }\n    function getPrev(keyframes, i, property) {\n      while (i >= 0) {\n        const keyframe = keyframes[i];\n        if (keyframe.value[property] !== null) return keyframe;\n        i--;\n      }\n      return null;\n    }\n    function getNext(keyframes, i, property) {\n      while (i < keyframes.length) {\n        const keyframe = keyframes[i];\n        if (keyframe.value[property] !== null) return keyframe;\n        i++;\n      }\n      return null;\n    }\n    function interpolate(key, prev, next, property) {\n      if (next.time - prev.time === 0) {\n        key.value[property] = prev.value[property];\n        return;\n      }\n      key.value[property] = (key.time - prev.time) * (next.value[property] - prev.value[property]) / (next.time - prev.time) + prev.value[property];\n    }\n\n    // animation clips\n\n    function parseAnimationClip(xml) {\n      const data = {\n        name: xml.getAttribute('id') || 'default',\n        start: parseFloat(xml.getAttribute('start') || 0),\n        end: parseFloat(xml.getAttribute('end') || 0),\n        animations: []\n      };\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'instance_animation':\n            data.animations.push(parseId(child.getAttribute('url')));\n            break;\n        }\n      }\n      library.clips[xml.getAttribute('id')] = data;\n    }\n    function buildAnimationClip(data) {\n      const tracks = [];\n      const name = data.name;\n      const duration = data.end - data.start || -1;\n      const animations = data.animations;\n      for (let i = 0, il = animations.length; i < il; i++) {\n        const animationTracks = getAnimation(animations[i]);\n        for (let j = 0, jl = animationTracks.length; j < jl; j++) {\n          tracks.push(animationTracks[j]);\n        }\n      }\n      return new AnimationClip(name, duration, tracks);\n    }\n    function getAnimationClip(id) {\n      return getBuild(library.clips[id], buildAnimationClip);\n    }\n\n    // controller\n\n    function parseController(xml) {\n      const data = {};\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'skin':\n            // there is exactly one skin per controller\n            data.id = parseId(child.getAttribute('source'));\n            data.skin = parseSkin(child);\n            break;\n          case 'morph':\n            data.id = parseId(child.getAttribute('source'));\n            console.warn('THREE.ColladaLoader: Morph target animation not supported yet.');\n            break;\n        }\n      }\n      library.controllers[xml.getAttribute('id')] = data;\n    }\n    function parseSkin(xml) {\n      const data = {\n        sources: {}\n      };\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'bind_shape_matrix':\n            data.bindShapeMatrix = parseFloats(child.textContent);\n            break;\n          case 'source':\n            const id = child.getAttribute('id');\n            data.sources[id] = parseSource(child);\n            break;\n          case 'joints':\n            data.joints = parseJoints(child);\n            break;\n          case 'vertex_weights':\n            data.vertexWeights = parseVertexWeights(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseJoints(xml) {\n      const data = {\n        inputs: {}\n      };\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'input':\n            const semantic = child.getAttribute('semantic');\n            const id = parseId(child.getAttribute('source'));\n            data.inputs[semantic] = id;\n            break;\n        }\n      }\n      return data;\n    }\n    function parseVertexWeights(xml) {\n      const data = {\n        inputs: {}\n      };\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'input':\n            const semantic = child.getAttribute('semantic');\n            const id = parseId(child.getAttribute('source'));\n            const offset = parseInt(child.getAttribute('offset'));\n            data.inputs[semantic] = {\n              id: id,\n              offset: offset\n            };\n            break;\n          case 'vcount':\n            data.vcount = parseInts(child.textContent);\n            break;\n          case 'v':\n            data.v = parseInts(child.textContent);\n            break;\n        }\n      }\n      return data;\n    }\n    function buildController(data) {\n      const build = {\n        id: data.id\n      };\n      const geometry = library.geometries[build.id];\n      if (data.skin !== undefined) {\n        build.skin = buildSkin(data.skin);\n\n        // we enhance the 'sources' property of the corresponding geometry with our skin data\n\n        geometry.sources.skinIndices = build.skin.indices;\n        geometry.sources.skinWeights = build.skin.weights;\n      }\n      return build;\n    }\n    function buildSkin(data) {\n      const BONE_LIMIT = 4;\n      const build = {\n        joints: [],\n        // this must be an array to preserve the joint order\n        indices: {\n          array: [],\n          stride: BONE_LIMIT\n        },\n        weights: {\n          array: [],\n          stride: BONE_LIMIT\n        }\n      };\n      const sources = data.sources;\n      const vertexWeights = data.vertexWeights;\n      const vcount = vertexWeights.vcount;\n      const v = vertexWeights.v;\n      const jointOffset = vertexWeights.inputs.JOINT.offset;\n      const weightOffset = vertexWeights.inputs.WEIGHT.offset;\n      const jointSource = data.sources[data.joints.inputs.JOINT];\n      const inverseSource = data.sources[data.joints.inputs.INV_BIND_MATRIX];\n      const weights = sources[vertexWeights.inputs.WEIGHT.id].array;\n      let stride = 0;\n      let i, j, l;\n\n      // procces skin data for each vertex\n\n      for (i = 0, l = vcount.length; i < l; i++) {\n        const jointCount = vcount[i]; // this is the amount of joints that affect a single vertex\n        const vertexSkinData = [];\n        for (j = 0; j < jointCount; j++) {\n          const skinIndex = v[stride + jointOffset];\n          const weightId = v[stride + weightOffset];\n          const skinWeight = weights[weightId];\n          vertexSkinData.push({\n            index: skinIndex,\n            weight: skinWeight\n          });\n          stride += 2;\n        }\n\n        // we sort the joints in descending order based on the weights.\n        // this ensures, we only procced the most important joints of the vertex\n\n        vertexSkinData.sort(descending);\n\n        // now we provide for each vertex a set of four index and weight values.\n        // the order of the skin data matches the order of vertices\n\n        for (j = 0; j < BONE_LIMIT; j++) {\n          const d = vertexSkinData[j];\n          if (d !== undefined) {\n            build.indices.array.push(d.index);\n            build.weights.array.push(d.weight);\n          } else {\n            build.indices.array.push(0);\n            build.weights.array.push(0);\n          }\n        }\n      }\n\n      // setup bind matrix\n\n      if (data.bindShapeMatrix) {\n        build.bindMatrix = new Matrix4().fromArray(data.bindShapeMatrix).transpose();\n      } else {\n        build.bindMatrix = new Matrix4().identity();\n      }\n\n      // process bones and inverse bind matrix data\n\n      for (i = 0, l = jointSource.array.length; i < l; i++) {\n        const name = jointSource.array[i];\n        const boneInverse = new Matrix4().fromArray(inverseSource.array, i * inverseSource.stride).transpose();\n        build.joints.push({\n          name: name,\n          boneInverse: boneInverse\n        });\n      }\n      return build;\n\n      // array sort function\n\n      function descending(a, b) {\n        return b.weight - a.weight;\n      }\n    }\n    function getController(id) {\n      return getBuild(library.controllers[id], buildController);\n    }\n\n    // image\n\n    function parseImage(xml) {\n      const data = {\n        init_from: getElementsByTagName(xml, 'init_from')[0].textContent\n      };\n      library.images[xml.getAttribute('id')] = data;\n    }\n    function buildImage(data) {\n      if (data.build !== undefined) return data.build;\n      return data.init_from;\n    }\n    function getImage(id) {\n      const data = library.images[id];\n      if (data !== undefined) {\n        return getBuild(data, buildImage);\n      }\n      console.warn('THREE.ColladaLoader: Couldn\\'t find image with ID:', id);\n      return null;\n    }\n\n    // effect\n\n    function parseEffect(xml) {\n      const data = {};\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'profile_COMMON':\n            data.profile = parseEffectProfileCOMMON(child);\n            break;\n        }\n      }\n      library.effects[xml.getAttribute('id')] = data;\n    }\n    function parseEffectProfileCOMMON(xml) {\n      const data = {\n        surfaces: {},\n        samplers: {}\n      };\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'newparam':\n            parseEffectNewparam(child, data);\n            break;\n          case 'technique':\n            data.technique = parseEffectTechnique(child);\n            break;\n          case 'extra':\n            data.extra = parseEffectExtra(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectNewparam(xml, data) {\n      const sid = xml.getAttribute('sid');\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'surface':\n            data.surfaces[sid] = parseEffectSurface(child);\n            break;\n          case 'sampler2D':\n            data.samplers[sid] = parseEffectSampler(child);\n            break;\n        }\n      }\n    }\n    function parseEffectSurface(xml) {\n      const data = {};\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'init_from':\n            data.init_from = child.textContent;\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectSampler(xml) {\n      const data = {};\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'source':\n            data.source = child.textContent;\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectTechnique(xml) {\n      const data = {};\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'constant':\n          case 'lambert':\n          case 'blinn':\n          case 'phong':\n            data.type = child.nodeName;\n            data.parameters = parseEffectParameters(child);\n            break;\n          case 'extra':\n            data.extra = parseEffectExtra(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectParameters(xml) {\n      const data = {};\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'emission':\n          case 'diffuse':\n          case 'specular':\n          case 'bump':\n          case 'ambient':\n          case 'shininess':\n          case 'transparency':\n            data[child.nodeName] = parseEffectParameter(child);\n            break;\n          case 'transparent':\n            data[child.nodeName] = {\n              opaque: child.hasAttribute('opaque') ? child.getAttribute('opaque') : 'A_ONE',\n              data: parseEffectParameter(child)\n            };\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectParameter(xml) {\n      const data = {};\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'color':\n            data[child.nodeName] = parseFloats(child.textContent);\n            break;\n          case 'float':\n            data[child.nodeName] = parseFloat(child.textContent);\n            break;\n          case 'texture':\n            data[child.nodeName] = {\n              id: child.getAttribute('texture'),\n              extra: parseEffectParameterTexture(child)\n            };\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectParameterTexture(xml) {\n      const data = {\n        technique: {}\n      };\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'extra':\n            parseEffectParameterTextureExtra(child, data);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectParameterTextureExtra(xml, data) {\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'technique':\n            parseEffectParameterTextureExtraTechnique(child, data);\n            break;\n        }\n      }\n    }\n    function parseEffectParameterTextureExtraTechnique(xml, data) {\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'repeatU':\n          case 'repeatV':\n          case 'offsetU':\n          case 'offsetV':\n            data.technique[child.nodeName] = parseFloat(child.textContent);\n            break;\n          case 'wrapU':\n          case 'wrapV':\n            // some files have values for wrapU/wrapV which become NaN via parseInt\n\n            if (child.textContent.toUpperCase() === 'TRUE') {\n              data.technique[child.nodeName] = 1;\n            } else if (child.textContent.toUpperCase() === 'FALSE') {\n              data.technique[child.nodeName] = 0;\n            } else {\n              data.technique[child.nodeName] = parseInt(child.textContent);\n            }\n            break;\n          case 'bump':\n            data[child.nodeName] = parseEffectExtraTechniqueBump(child);\n            break;\n        }\n      }\n    }\n    function parseEffectExtra(xml) {\n      const data = {};\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'technique':\n            data.technique = parseEffectExtraTechnique(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectExtraTechnique(xml) {\n      const data = {};\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'double_sided':\n            data[child.nodeName] = parseInt(child.textContent);\n            break;\n          case 'bump':\n            data[child.nodeName] = parseEffectExtraTechniqueBump(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseEffectExtraTechniqueBump(xml) {\n      const data = {};\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'texture':\n            data[child.nodeName] = {\n              id: child.getAttribute('texture'),\n              texcoord: child.getAttribute('texcoord'),\n              extra: parseEffectParameterTexture(child)\n            };\n            break;\n        }\n      }\n      return data;\n    }\n    function buildEffect(data) {\n      return data;\n    }\n    function getEffect(id) {\n      return getBuild(library.effects[id], buildEffect);\n    }\n\n    // material\n\n    function parseMaterial(xml) {\n      const data = {\n        name: xml.getAttribute('name')\n      };\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'instance_effect':\n            data.url = parseId(child.getAttribute('url'));\n            break;\n        }\n      }\n      library.materials[xml.getAttribute('id')] = data;\n    }\n    function getTextureLoader(image) {\n      let loader;\n      let extension = image.slice((image.lastIndexOf('.') - 1 >>> 0) + 2); // http://www.jstips.co/en/javascript/get-file-extension/\n      extension = extension.toLowerCase();\n      switch (extension) {\n        case 'tga':\n          loader = tgaLoader;\n          break;\n        default:\n          loader = textureLoader;\n      }\n      return loader;\n    }\n    function buildMaterial(data) {\n      const effect = getEffect(data.url);\n      const technique = effect.profile.technique;\n      let material;\n      switch (technique.type) {\n        case 'phong':\n        case 'blinn':\n          material = new MeshPhongMaterial();\n          break;\n        case 'lambert':\n          material = new MeshLambertMaterial();\n          break;\n        default:\n          material = new MeshBasicMaterial();\n          break;\n      }\n      material.name = data.name || '';\n      function getTexture(textureObject) {\n        let encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        const sampler = effect.profile.samplers[textureObject.id];\n        let image = null;\n\n        // get image\n\n        if (sampler !== undefined) {\n          const surface = effect.profile.surfaces[sampler.source];\n          image = getImage(surface.init_from);\n        } else {\n          console.warn('THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).');\n          image = getImage(textureObject.id);\n        }\n\n        // create texture if image is avaiable\n\n        if (image !== null) {\n          const loader = getTextureLoader(image);\n          if (loader !== undefined) {\n            const texture = loader.load(image);\n            const extra = textureObject.extra;\n            if (extra !== undefined && extra.technique !== undefined && isEmpty(extra.technique) === false) {\n              const technique = extra.technique;\n              texture.wrapS = technique.wrapU ? RepeatWrapping : ClampToEdgeWrapping;\n              texture.wrapT = technique.wrapV ? RepeatWrapping : ClampToEdgeWrapping;\n              texture.offset.set(technique.offsetU || 0, technique.offsetV || 0);\n              texture.repeat.set(technique.repeatU || 1, technique.repeatV || 1);\n            } else {\n              texture.wrapS = RepeatWrapping;\n              texture.wrapT = RepeatWrapping;\n            }\n            if (encoding !== null) {\n              texture.encoding = encoding;\n            }\n            return texture;\n          } else {\n            console.warn('THREE.ColladaLoader: Loader for texture %s not found.', image);\n            return null;\n          }\n        } else {\n          console.warn('THREE.ColladaLoader: Couldn\\'t create texture with ID:', textureObject.id);\n          return null;\n        }\n      }\n      const parameters = technique.parameters;\n      for (const key in parameters) {\n        const parameter = parameters[key];\n        switch (key) {\n          case 'diffuse':\n            if (parameter.color) material.color.fromArray(parameter.color);\n            if (parameter.texture) material.map = getTexture(parameter.texture, sRGBEncoding);\n            break;\n          case 'specular':\n            if (parameter.color && material.specular) material.specular.fromArray(parameter.color);\n            if (parameter.texture) material.specularMap = getTexture(parameter.texture);\n            break;\n          case 'bump':\n            if (parameter.texture) material.normalMap = getTexture(parameter.texture);\n            break;\n          case 'ambient':\n            if (parameter.texture) material.lightMap = getTexture(parameter.texture, sRGBEncoding);\n            break;\n          case 'shininess':\n            if (parameter.float && material.shininess) material.shininess = parameter.float;\n            break;\n          case 'emission':\n            if (parameter.color && material.emissive) material.emissive.fromArray(parameter.color);\n            if (parameter.texture) material.emissiveMap = getTexture(parameter.texture, sRGBEncoding);\n            break;\n        }\n      }\n      material.color.convertSRGBToLinear();\n      if (material.specular) material.specular.convertSRGBToLinear();\n      if (material.emissive) material.emissive.convertSRGBToLinear();\n\n      //\n\n      let transparent = parameters['transparent'];\n      let transparency = parameters['transparency'];\n\n      // <transparency> does not exist but <transparent>\n\n      if (transparency === undefined && transparent) {\n        transparency = {\n          float: 1\n        };\n      }\n\n      // <transparent> does not exist but <transparency>\n\n      if (transparent === undefined && transparency) {\n        transparent = {\n          opaque: 'A_ONE',\n          data: {\n            color: [1, 1, 1, 1]\n          }\n        };\n      }\n      if (transparent && transparency) {\n        // handle case if a texture exists but no color\n\n        if (transparent.data.texture) {\n          // we do not set an alpha map (see #13792)\n\n          material.transparent = true;\n        } else {\n          const color = transparent.data.color;\n          switch (transparent.opaque) {\n            case 'A_ONE':\n              material.opacity = color[3] * transparency.float;\n              break;\n            case 'RGB_ZERO':\n              material.opacity = 1 - color[0] * transparency.float;\n              break;\n            case 'A_ZERO':\n              material.opacity = 1 - color[3] * transparency.float;\n              break;\n            case 'RGB_ONE':\n              material.opacity = color[0] * transparency.float;\n              break;\n            default:\n              console.warn('THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque);\n          }\n          if (material.opacity < 1) material.transparent = true;\n        }\n      }\n\n      //\n\n      if (technique.extra !== undefined && technique.extra.technique !== undefined) {\n        const techniques = technique.extra.technique;\n        for (const k in techniques) {\n          const v = techniques[k];\n          switch (k) {\n            case 'double_sided':\n              material.side = v === 1 ? DoubleSide : FrontSide;\n              break;\n            case 'bump':\n              material.normalMap = getTexture(v.texture);\n              material.normalScale = new Vector2(1, 1);\n              break;\n          }\n        }\n      }\n      return material;\n    }\n    function getMaterial(id) {\n      return getBuild(library.materials[id], buildMaterial);\n    }\n\n    // camera\n\n    function parseCamera(xml) {\n      const data = {\n        name: xml.getAttribute('name')\n      };\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'optics':\n            data.optics = parseCameraOptics(child);\n            break;\n        }\n      }\n      library.cameras[xml.getAttribute('id')] = data;\n    }\n    function parseCameraOptics(xml) {\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        switch (child.nodeName) {\n          case 'technique_common':\n            return parseCameraTechnique(child);\n        }\n      }\n      return {};\n    }\n    function parseCameraTechnique(xml) {\n      const data = {};\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        switch (child.nodeName) {\n          case 'perspective':\n          case 'orthographic':\n            data.technique = child.nodeName;\n            data.parameters = parseCameraParameters(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseCameraParameters(xml) {\n      const data = {};\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        switch (child.nodeName) {\n          case 'xfov':\n          case 'yfov':\n          case 'xmag':\n          case 'ymag':\n          case 'znear':\n          case 'zfar':\n          case 'aspect_ratio':\n            data[child.nodeName] = parseFloat(child.textContent);\n            break;\n        }\n      }\n      return data;\n    }\n    function buildCamera(data) {\n      let camera;\n      switch (data.optics.technique) {\n        case 'perspective':\n          camera = new PerspectiveCamera(data.optics.parameters.yfov, data.optics.parameters.aspect_ratio, data.optics.parameters.znear, data.optics.parameters.zfar);\n          break;\n        case 'orthographic':\n          let ymag = data.optics.parameters.ymag;\n          let xmag = data.optics.parameters.xmag;\n          const aspectRatio = data.optics.parameters.aspect_ratio;\n          xmag = xmag === undefined ? ymag * aspectRatio : xmag;\n          ymag = ymag === undefined ? xmag / aspectRatio : ymag;\n          xmag *= 0.5;\n          ymag *= 0.5;\n          camera = new OrthographicCamera(-xmag, xmag, ymag, -ymag,\n          // left, right, top, bottom\n          data.optics.parameters.znear, data.optics.parameters.zfar);\n          break;\n        default:\n          camera = new PerspectiveCamera();\n          break;\n      }\n      camera.name = data.name || '';\n      return camera;\n    }\n    function getCamera(id) {\n      const data = library.cameras[id];\n      if (data !== undefined) {\n        return getBuild(data, buildCamera);\n      }\n      console.warn('THREE.ColladaLoader: Couldn\\'t find camera with ID:', id);\n      return null;\n    }\n\n    // light\n\n    function parseLight(xml) {\n      let data = {};\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'technique_common':\n            data = parseLightTechnique(child);\n            break;\n        }\n      }\n      library.lights[xml.getAttribute('id')] = data;\n    }\n    function parseLightTechnique(xml) {\n      const data = {};\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'directional':\n          case 'point':\n          case 'spot':\n          case 'ambient':\n            data.technique = child.nodeName;\n            data.parameters = parseLightParameters(child);\n        }\n      }\n      return data;\n    }\n    function parseLightParameters(xml) {\n      const data = {};\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'color':\n            const array = parseFloats(child.textContent);\n            data.color = new Color().fromArray(array).convertSRGBToLinear();\n            break;\n          case 'falloff_angle':\n            data.falloffAngle = parseFloat(child.textContent);\n            break;\n          case 'quadratic_attenuation':\n            const f = parseFloat(child.textContent);\n            data.distance = f ? Math.sqrt(1 / f) : 0;\n            break;\n        }\n      }\n      return data;\n    }\n    function buildLight(data) {\n      let light;\n      switch (data.technique) {\n        case 'directional':\n          light = new DirectionalLight();\n          break;\n        case 'point':\n          light = new PointLight();\n          break;\n        case 'spot':\n          light = new SpotLight();\n          break;\n        case 'ambient':\n          light = new AmbientLight();\n          break;\n      }\n      if (data.parameters.color) light.color.copy(data.parameters.color);\n      if (data.parameters.distance) light.distance = data.parameters.distance;\n      return light;\n    }\n    function getLight(id) {\n      const data = library.lights[id];\n      if (data !== undefined) {\n        return getBuild(data, buildLight);\n      }\n      console.warn('THREE.ColladaLoader: Couldn\\'t find light with ID:', id);\n      return null;\n    }\n\n    // geometry\n\n    function parseGeometry(xml) {\n      const data = {\n        name: xml.getAttribute('name'),\n        sources: {},\n        vertices: {},\n        primitives: []\n      };\n      const mesh = getElementsByTagName(xml, 'mesh')[0];\n\n      // the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep\n      if (mesh === undefined) return;\n      for (let i = 0; i < mesh.childNodes.length; i++) {\n        const child = mesh.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        const id = child.getAttribute('id');\n        switch (child.nodeName) {\n          case 'source':\n            data.sources[id] = parseSource(child);\n            break;\n          case 'vertices':\n            // data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];\n            data.vertices = parseGeometryVertices(child);\n            break;\n          case 'polygons':\n            console.warn('THREE.ColladaLoader: Unsupported primitive type: ', child.nodeName);\n            break;\n          case 'lines':\n          case 'linestrips':\n          case 'polylist':\n          case 'triangles':\n            data.primitives.push(parseGeometryPrimitive(child));\n            break;\n          default:\n            console.log(child);\n        }\n      }\n      library.geometries[xml.getAttribute('id')] = data;\n    }\n    function parseSource(xml) {\n      const data = {\n        array: [],\n        stride: 3\n      };\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'float_array':\n            data.array = parseFloats(child.textContent);\n            break;\n          case 'Name_array':\n            data.array = parseStrings(child.textContent);\n            break;\n          case 'technique_common':\n            const accessor = getElementsByTagName(child, 'accessor')[0];\n            if (accessor !== undefined) {\n              data.stride = parseInt(accessor.getAttribute('stride'));\n            }\n            break;\n        }\n      }\n      return data;\n    }\n    function parseGeometryVertices(xml) {\n      const data = {};\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        data[child.getAttribute('semantic')] = parseId(child.getAttribute('source'));\n      }\n      return data;\n    }\n    function parseGeometryPrimitive(xml) {\n      const primitive = {\n        type: xml.nodeName,\n        material: xml.getAttribute('material'),\n        count: parseInt(xml.getAttribute('count')),\n        inputs: {},\n        stride: 0,\n        hasUV: false\n      };\n      for (let i = 0, l = xml.childNodes.length; i < l; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'input':\n            const id = parseId(child.getAttribute('source'));\n            const semantic = child.getAttribute('semantic');\n            const offset = parseInt(child.getAttribute('offset'));\n            const set = parseInt(child.getAttribute('set'));\n            const inputname = set > 0 ? semantic + set : semantic;\n            primitive.inputs[inputname] = {\n              id: id,\n              offset: offset\n            };\n            primitive.stride = Math.max(primitive.stride, offset + 1);\n            if (semantic === 'TEXCOORD') primitive.hasUV = true;\n            break;\n          case 'vcount':\n            primitive.vcount = parseInts(child.textContent);\n            break;\n          case 'p':\n            primitive.p = parseInts(child.textContent);\n            break;\n        }\n      }\n      return primitive;\n    }\n    function groupPrimitives(primitives) {\n      const build = {};\n      for (let i = 0; i < primitives.length; i++) {\n        const primitive = primitives[i];\n        if (build[primitive.type] === undefined) build[primitive.type] = [];\n        build[primitive.type].push(primitive);\n      }\n      return build;\n    }\n    function checkUVCoordinates(primitives) {\n      let count = 0;\n      for (let i = 0, l = primitives.length; i < l; i++) {\n        const primitive = primitives[i];\n        if (primitive.hasUV === true) {\n          count++;\n        }\n      }\n      if (count > 0 && count < primitives.length) {\n        primitives.uvsNeedsFix = true;\n      }\n    }\n    function buildGeometry(data) {\n      const build = {};\n      const sources = data.sources;\n      const vertices = data.vertices;\n      const primitives = data.primitives;\n      if (primitives.length === 0) return {};\n\n      // our goal is to create one buffer geometry for a single type of primitives\n      // first, we group all primitives by their type\n\n      const groupedPrimitives = groupPrimitives(primitives);\n      for (const type in groupedPrimitives) {\n        const primitiveType = groupedPrimitives[type];\n\n        // second, ensure consistent uv coordinates for each type of primitives (polylist,triangles or lines)\n\n        checkUVCoordinates(primitiveType);\n\n        // third, create a buffer geometry for each type of primitives\n\n        build[type] = buildGeometryType(primitiveType, sources, vertices);\n      }\n      return build;\n    }\n    function buildGeometryType(primitives, sources, vertices) {\n      const build = {};\n      const position = {\n        array: [],\n        stride: 0\n      };\n      const normal = {\n        array: [],\n        stride: 0\n      };\n      const uv = {\n        array: [],\n        stride: 0\n      };\n      const uv2 = {\n        array: [],\n        stride: 0\n      };\n      const color = {\n        array: [],\n        stride: 0\n      };\n      const skinIndex = {\n        array: [],\n        stride: 4\n      };\n      const skinWeight = {\n        array: [],\n        stride: 4\n      };\n      const geometry = new BufferGeometry();\n      const materialKeys = [];\n      let start = 0;\n      for (let p = 0; p < primitives.length; p++) {\n        const primitive = primitives[p];\n        const inputs = primitive.inputs;\n\n        // groups\n\n        let count = 0;\n        switch (primitive.type) {\n          case 'lines':\n          case 'linestrips':\n            count = primitive.count * 2;\n            break;\n          case 'triangles':\n            count = primitive.count * 3;\n            break;\n          case 'polylist':\n            for (let g = 0; g < primitive.count; g++) {\n              const vc = primitive.vcount[g];\n              switch (vc) {\n                case 3:\n                  count += 3; // single triangle\n                  break;\n                case 4:\n                  count += 6; // quad, subdivided into two triangles\n                  break;\n                default:\n                  count += (vc - 2) * 3; // polylist with more than four vertices\n                  break;\n              }\n            }\n            break;\n          default:\n            console.warn('THREE.ColladaLoader: Unknow primitive type:', primitive.type);\n        }\n        geometry.addGroup(start, count, p);\n        start += count;\n\n        // material\n\n        if (primitive.material) {\n          materialKeys.push(primitive.material);\n        }\n\n        // geometry data\n\n        for (const name in inputs) {\n          const input = inputs[name];\n          switch (name) {\n            case 'VERTEX':\n              for (const key in vertices) {\n                const id = vertices[key];\n                switch (key) {\n                  case 'POSITION':\n                    const prevLength = position.array.length;\n                    buildGeometryData(primitive, sources[id], input.offset, position.array);\n                    position.stride = sources[id].stride;\n                    if (sources.skinWeights && sources.skinIndices) {\n                      buildGeometryData(primitive, sources.skinIndices, input.offset, skinIndex.array);\n                      buildGeometryData(primitive, sources.skinWeights, input.offset, skinWeight.array);\n                    }\n\n                    // see #3803\n\n                    if (primitive.hasUV === false && primitives.uvsNeedsFix === true) {\n                      const count = (position.array.length - prevLength) / position.stride;\n                      for (let i = 0; i < count; i++) {\n                        // fill missing uv coordinates\n\n                        uv.array.push(0, 0);\n                      }\n                    }\n                    break;\n                  case 'NORMAL':\n                    buildGeometryData(primitive, sources[id], input.offset, normal.array);\n                    normal.stride = sources[id].stride;\n                    break;\n                  case 'COLOR':\n                    buildGeometryData(primitive, sources[id], input.offset, color.array);\n                    color.stride = sources[id].stride;\n                    break;\n                  case 'TEXCOORD':\n                    buildGeometryData(primitive, sources[id], input.offset, uv.array);\n                    uv.stride = sources[id].stride;\n                    break;\n                  case 'TEXCOORD1':\n                    buildGeometryData(primitive, sources[id], input.offset, uv2.array);\n                    uv.stride = sources[id].stride;\n                    break;\n                  default:\n                    console.warn('THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key);\n                }\n              }\n              break;\n            case 'NORMAL':\n              buildGeometryData(primitive, sources[input.id], input.offset, normal.array);\n              normal.stride = sources[input.id].stride;\n              break;\n            case 'COLOR':\n              buildGeometryData(primitive, sources[input.id], input.offset, color.array, true);\n              color.stride = sources[input.id].stride;\n              break;\n            case 'TEXCOORD':\n              buildGeometryData(primitive, sources[input.id], input.offset, uv.array);\n              uv.stride = sources[input.id].stride;\n              break;\n            case 'TEXCOORD1':\n              buildGeometryData(primitive, sources[input.id], input.offset, uv2.array);\n              uv2.stride = sources[input.id].stride;\n              break;\n          }\n        }\n      }\n\n      // build geometry\n\n      if (position.array.length > 0) geometry.setAttribute('position', new Float32BufferAttribute(position.array, position.stride));\n      if (normal.array.length > 0) geometry.setAttribute('normal', new Float32BufferAttribute(normal.array, normal.stride));\n      if (color.array.length > 0) geometry.setAttribute('color', new Float32BufferAttribute(color.array, color.stride));\n      if (uv.array.length > 0) geometry.setAttribute('uv', new Float32BufferAttribute(uv.array, uv.stride));\n      if (uv2.array.length > 0) geometry.setAttribute('uv2', new Float32BufferAttribute(uv2.array, uv2.stride));\n      if (skinIndex.array.length > 0) geometry.setAttribute('skinIndex', new Float32BufferAttribute(skinIndex.array, skinIndex.stride));\n      if (skinWeight.array.length > 0) geometry.setAttribute('skinWeight', new Float32BufferAttribute(skinWeight.array, skinWeight.stride));\n      build.data = geometry;\n      build.type = primitives[0].type;\n      build.materialKeys = materialKeys;\n      return build;\n    }\n    function buildGeometryData(primitive, source, offset, array) {\n      let isColor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      const indices = primitive.p;\n      const stride = primitive.stride;\n      const vcount = primitive.vcount;\n      function pushVector(i) {\n        let index = indices[i + offset] * sourceStride;\n        const length = index + sourceStride;\n        for (; index < length; index++) {\n          array.push(sourceArray[index]);\n        }\n        if (isColor) {\n          // convert the vertex colors from srgb to linear if present\n          const startIndex = array.length - sourceStride - 1;\n          tempColor.setRGB(array[startIndex + 0], array[startIndex + 1], array[startIndex + 2]).convertSRGBToLinear();\n          array[startIndex + 0] = tempColor.r;\n          array[startIndex + 1] = tempColor.g;\n          array[startIndex + 2] = tempColor.b;\n        }\n      }\n      const sourceArray = source.array;\n      const sourceStride = source.stride;\n      if (primitive.vcount !== undefined) {\n        let index = 0;\n        for (let i = 0, l = vcount.length; i < l; i++) {\n          const count = vcount[i];\n          if (count === 4) {\n            const a = index + stride * 0;\n            const b = index + stride * 1;\n            const c = index + stride * 2;\n            const d = index + stride * 3;\n            pushVector(a);\n            pushVector(b);\n            pushVector(d);\n            pushVector(b);\n            pushVector(c);\n            pushVector(d);\n          } else if (count === 3) {\n            const a = index + stride * 0;\n            const b = index + stride * 1;\n            const c = index + stride * 2;\n            pushVector(a);\n            pushVector(b);\n            pushVector(c);\n          } else if (count > 4) {\n            for (let k = 1, kl = count - 2; k <= kl; k++) {\n              const a = index + stride * 0;\n              const b = index + stride * k;\n              const c = index + stride * (k + 1);\n              pushVector(a);\n              pushVector(b);\n              pushVector(c);\n            }\n          }\n          index += stride * count;\n        }\n      } else {\n        for (let i = 0, l = indices.length; i < l; i += stride) {\n          pushVector(i);\n        }\n      }\n    }\n    function getGeometry(id) {\n      return getBuild(library.geometries[id], buildGeometry);\n    }\n\n    // kinematics\n\n    function parseKinematicsModel(xml) {\n      const data = {\n        name: xml.getAttribute('name') || '',\n        joints: {},\n        links: []\n      };\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'technique_common':\n            parseKinematicsTechniqueCommon(child, data);\n            break;\n        }\n      }\n      library.kinematicsModels[xml.getAttribute('id')] = data;\n    }\n    function buildKinematicsModel(data) {\n      if (data.build !== undefined) return data.build;\n      return data;\n    }\n    function getKinematicsModel(id) {\n      return getBuild(library.kinematicsModels[id], buildKinematicsModel);\n    }\n    function parseKinematicsTechniqueCommon(xml, data) {\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'joint':\n            data.joints[child.getAttribute('sid')] = parseKinematicsJoint(child);\n            break;\n          case 'link':\n            data.links.push(parseKinematicsLink(child));\n            break;\n        }\n      }\n    }\n    function parseKinematicsJoint(xml) {\n      let data;\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'prismatic':\n          case 'revolute':\n            data = parseKinematicsJointParameter(child);\n            break;\n        }\n      }\n      return data;\n    }\n    function parseKinematicsJointParameter(xml) {\n      const data = {\n        sid: xml.getAttribute('sid'),\n        name: xml.getAttribute('name') || '',\n        axis: new Vector3(),\n        limits: {\n          min: 0,\n          max: 0\n        },\n        type: xml.nodeName,\n        static: false,\n        zeroPosition: 0,\n        middlePosition: 0\n      };\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'axis':\n            const array = parseFloats(child.textContent);\n            data.axis.fromArray(array);\n            break;\n          case 'limits':\n            const max = child.getElementsByTagName('max')[0];\n            const min = child.getElementsByTagName('min')[0];\n            data.limits.max = parseFloat(max.textContent);\n            data.limits.min = parseFloat(min.textContent);\n            break;\n        }\n      }\n\n      // if min is equal to or greater than max, consider the joint static\n\n      if (data.limits.min >= data.limits.max) {\n        data.static = true;\n      }\n\n      // calculate middle position\n\n      data.middlePosition = (data.limits.min + data.limits.max) / 2.0;\n      return data;\n    }\n    function parseKinematicsLink(xml) {\n      const data = {\n        sid: xml.getAttribute('sid'),\n        name: xml.getAttribute('name') || '',\n        attachments: [],\n        transforms: []\n      };\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'attachment_full':\n            data.attachments.push(parseKinematicsAttachment(child));\n            break;\n          case 'matrix':\n          case 'translate':\n          case 'rotate':\n            data.transforms.push(parseKinematicsTransform(child));\n            break;\n        }\n      }\n      return data;\n    }\n    function parseKinematicsAttachment(xml) {\n      const data = {\n        joint: xml.getAttribute('joint').split('/').pop(),\n        transforms: [],\n        links: []\n      };\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'link':\n            data.links.push(parseKinematicsLink(child));\n            break;\n          case 'matrix':\n          case 'translate':\n          case 'rotate':\n            data.transforms.push(parseKinematicsTransform(child));\n            break;\n        }\n      }\n      return data;\n    }\n    function parseKinematicsTransform(xml) {\n      const data = {\n        type: xml.nodeName\n      };\n      const array = parseFloats(xml.textContent);\n      switch (data.type) {\n        case 'matrix':\n          data.obj = new Matrix4();\n          data.obj.fromArray(array).transpose();\n          break;\n        case 'translate':\n          data.obj = new Vector3();\n          data.obj.fromArray(array);\n          break;\n        case 'rotate':\n          data.obj = new Vector3();\n          data.obj.fromArray(array);\n          data.angle = MathUtils.degToRad(array[3]);\n          break;\n      }\n      return data;\n    }\n\n    // physics\n\n    function parsePhysicsModel(xml) {\n      const data = {\n        name: xml.getAttribute('name') || '',\n        rigidBodies: {}\n      };\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'rigid_body':\n            data.rigidBodies[child.getAttribute('name')] = {};\n            parsePhysicsRigidBody(child, data.rigidBodies[child.getAttribute('name')]);\n            break;\n        }\n      }\n      library.physicsModels[xml.getAttribute('id')] = data;\n    }\n    function parsePhysicsRigidBody(xml, data) {\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'technique_common':\n            parsePhysicsTechniqueCommon(child, data);\n            break;\n        }\n      }\n    }\n    function parsePhysicsTechniqueCommon(xml, data) {\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'inertia':\n            data.inertia = parseFloats(child.textContent);\n            break;\n          case 'mass':\n            data.mass = parseFloats(child.textContent)[0];\n            break;\n        }\n      }\n    }\n\n    // scene\n\n    function parseKinematicsScene(xml) {\n      const data = {\n        bindJointAxis: []\n      };\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'bind_joint_axis':\n            data.bindJointAxis.push(parseKinematicsBindJointAxis(child));\n            break;\n        }\n      }\n      library.kinematicsScenes[parseId(xml.getAttribute('url'))] = data;\n    }\n    function parseKinematicsBindJointAxis(xml) {\n      const data = {\n        target: xml.getAttribute('target').split('/').pop()\n      };\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        switch (child.nodeName) {\n          case 'axis':\n            const param = child.getElementsByTagName('param')[0];\n            data.axis = param.textContent;\n            const tmpJointIndex = data.axis.split('inst_').pop().split('axis')[0];\n            data.jointIndex = tmpJointIndex.substring(0, tmpJointIndex.length - 1);\n            break;\n        }\n      }\n      return data;\n    }\n    function buildKinematicsScene(data) {\n      if (data.build !== undefined) return data.build;\n      return data;\n    }\n    function getKinematicsScene(id) {\n      return getBuild(library.kinematicsScenes[id], buildKinematicsScene);\n    }\n    function setupKinematics() {\n      const kinematicsModelId = Object.keys(library.kinematicsModels)[0];\n      const kinematicsSceneId = Object.keys(library.kinematicsScenes)[0];\n      const visualSceneId = Object.keys(library.visualScenes)[0];\n      if (kinematicsModelId === undefined || kinematicsSceneId === undefined) return;\n      const kinematicsModel = getKinematicsModel(kinematicsModelId);\n      const kinematicsScene = getKinematicsScene(kinematicsSceneId);\n      const visualScene = getVisualScene(visualSceneId);\n      const bindJointAxis = kinematicsScene.bindJointAxis;\n      const jointMap = {};\n      for (let i = 0, l = bindJointAxis.length; i < l; i++) {\n        const axis = bindJointAxis[i];\n\n        // the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'\n\n        const targetElement = collada.querySelector('[sid=\"' + axis.target + '\"]');\n        if (targetElement) {\n          // get the parent of the transform element\n\n          const parentVisualElement = targetElement.parentElement;\n\n          // connect the joint of the kinematics model with the element in the visual scene\n\n          connect(axis.jointIndex, parentVisualElement);\n        }\n      }\n      function connect(jointIndex, visualElement) {\n        const visualElementName = visualElement.getAttribute('name');\n        const joint = kinematicsModel.joints[jointIndex];\n        visualScene.traverse(function (object) {\n          if (object.name === visualElementName) {\n            jointMap[jointIndex] = {\n              object: object,\n              transforms: buildTransformList(visualElement),\n              joint: joint,\n              position: joint.zeroPosition\n            };\n          }\n        });\n      }\n      const m0 = new Matrix4();\n      kinematics = {\n        joints: kinematicsModel && kinematicsModel.joints,\n        getJointValue: function (jointIndex) {\n          const jointData = jointMap[jointIndex];\n          if (jointData) {\n            return jointData.position;\n          } else {\n            console.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' doesn\\'t exist.');\n          }\n        },\n        setJointValue: function (jointIndex, value) {\n          const jointData = jointMap[jointIndex];\n          if (jointData) {\n            const joint = jointData.joint;\n            if (value > joint.limits.max || value < joint.limits.min) {\n              console.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ').');\n            } else if (joint.static) {\n              console.warn('THREE.ColladaLoader: Joint ' + jointIndex + ' is static.');\n            } else {\n              const object = jointData.object;\n              const axis = joint.axis;\n              const transforms = jointData.transforms;\n              matrix.identity();\n\n              // each update, we have to apply all transforms in the correct order\n\n              for (let i = 0; i < transforms.length; i++) {\n                const transform = transforms[i];\n\n                // if there is a connection of the transform node with a joint, apply the joint value\n\n                if (transform.sid && transform.sid.indexOf(jointIndex) !== -1) {\n                  switch (joint.type) {\n                    case 'revolute':\n                      matrix.multiply(m0.makeRotationAxis(axis, MathUtils.degToRad(value)));\n                      break;\n                    case 'prismatic':\n                      matrix.multiply(m0.makeTranslation(axis.x * value, axis.y * value, axis.z * value));\n                      break;\n                    default:\n                      console.warn('THREE.ColladaLoader: Unknown joint type: ' + joint.type);\n                      break;\n                  }\n                } else {\n                  switch (transform.type) {\n                    case 'matrix':\n                      matrix.multiply(transform.obj);\n                      break;\n                    case 'translate':\n                      matrix.multiply(m0.makeTranslation(transform.obj.x, transform.obj.y, transform.obj.z));\n                      break;\n                    case 'scale':\n                      matrix.scale(transform.obj);\n                      break;\n                    case 'rotate':\n                      matrix.multiply(m0.makeRotationAxis(transform.obj, transform.angle));\n                      break;\n                  }\n                }\n              }\n              object.matrix.copy(matrix);\n              object.matrix.decompose(object.position, object.quaternion, object.scale);\n              jointMap[jointIndex].position = value;\n            }\n          } else {\n            console.log('THREE.ColladaLoader: ' + jointIndex + ' does not exist.');\n          }\n        }\n      };\n    }\n    function buildTransformList(node) {\n      const transforms = [];\n      const xml = collada.querySelector('[id=\"' + node.id + '\"]');\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        let array, vector;\n        switch (child.nodeName) {\n          case 'matrix':\n            array = parseFloats(child.textContent);\n            const matrix = new Matrix4().fromArray(array).transpose();\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: matrix\n            });\n            break;\n          case 'translate':\n          case 'scale':\n            array = parseFloats(child.textContent);\n            vector = new Vector3().fromArray(array);\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: vector\n            });\n            break;\n          case 'rotate':\n            array = parseFloats(child.textContent);\n            vector = new Vector3().fromArray(array);\n            const angle = MathUtils.degToRad(array[3]);\n            transforms.push({\n              sid: child.getAttribute('sid'),\n              type: child.nodeName,\n              obj: vector,\n              angle: angle\n            });\n            break;\n        }\n      }\n      return transforms;\n    }\n\n    // nodes\n\n    function prepareNodes(xml) {\n      const elements = xml.getElementsByTagName('node');\n\n      // ensure all node elements have id attributes\n\n      for (let i = 0; i < elements.length; i++) {\n        const element = elements[i];\n        if (element.hasAttribute('id') === false) {\n          element.setAttribute('id', generateId());\n        }\n      }\n    }\n    const matrix = new Matrix4();\n    const vector = new Vector3();\n    function parseNode(xml) {\n      const data = {\n        name: xml.getAttribute('name') || '',\n        type: xml.getAttribute('type'),\n        id: xml.getAttribute('id'),\n        sid: xml.getAttribute('sid'),\n        matrix: new Matrix4(),\n        nodes: [],\n        instanceCameras: [],\n        instanceControllers: [],\n        instanceLights: [],\n        instanceGeometries: [],\n        instanceNodes: [],\n        transforms: {}\n      };\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        if (child.nodeType !== 1) continue;\n        let array;\n        switch (child.nodeName) {\n          case 'node':\n            data.nodes.push(child.getAttribute('id'));\n            parseNode(child);\n            break;\n          case 'instance_camera':\n            data.instanceCameras.push(parseId(child.getAttribute('url')));\n            break;\n          case 'instance_controller':\n            data.instanceControllers.push(parseNodeInstance(child));\n            break;\n          case 'instance_light':\n            data.instanceLights.push(parseId(child.getAttribute('url')));\n            break;\n          case 'instance_geometry':\n            data.instanceGeometries.push(parseNodeInstance(child));\n            break;\n          case 'instance_node':\n            data.instanceNodes.push(parseId(child.getAttribute('url')));\n            break;\n          case 'matrix':\n            array = parseFloats(child.textContent);\n            data.matrix.multiply(matrix.fromArray(array).transpose());\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n          case 'translate':\n            array = parseFloats(child.textContent);\n            vector.fromArray(array);\n            data.matrix.multiply(matrix.makeTranslation(vector.x, vector.y, vector.z));\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n          case 'rotate':\n            array = parseFloats(child.textContent);\n            const angle = MathUtils.degToRad(array[3]);\n            data.matrix.multiply(matrix.makeRotationAxis(vector.fromArray(array), angle));\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n          case 'scale':\n            array = parseFloats(child.textContent);\n            data.matrix.scale(vector.fromArray(array));\n            data.transforms[child.getAttribute('sid')] = child.nodeName;\n            break;\n          case 'extra':\n            break;\n          default:\n            console.log(child);\n        }\n      }\n      if (hasNode(data.id)) {\n        console.warn('THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.', data.id);\n      } else {\n        library.nodes[data.id] = data;\n      }\n      return data;\n    }\n    function parseNodeInstance(xml) {\n      const data = {\n        id: parseId(xml.getAttribute('url')),\n        materials: {},\n        skeletons: []\n      };\n      for (let i = 0; i < xml.childNodes.length; i++) {\n        const child = xml.childNodes[i];\n        switch (child.nodeName) {\n          case 'bind_material':\n            const instances = child.getElementsByTagName('instance_material');\n            for (let j = 0; j < instances.length; j++) {\n              const instance = instances[j];\n              const symbol = instance.getAttribute('symbol');\n              const target = instance.getAttribute('target');\n              data.materials[symbol] = parseId(target);\n            }\n            break;\n          case 'skeleton':\n            data.skeletons.push(parseId(child.textContent));\n            break;\n          default:\n            break;\n        }\n      }\n      return data;\n    }\n    function buildSkeleton(skeletons, joints) {\n      const boneData = [];\n      const sortedBoneData = [];\n      let i, j, data;\n\n      // a skeleton can have multiple root bones. collada expresses this\n      // situtation with multiple \"skeleton\" tags per controller instance\n\n      for (i = 0; i < skeletons.length; i++) {\n        const skeleton = skeletons[i];\n        let root;\n        if (hasNode(skeleton)) {\n          root = getNode(skeleton);\n          buildBoneHierarchy(root, joints, boneData);\n        } else if (hasVisualScene(skeleton)) {\n          // handle case where the skeleton refers to the visual scene (#13335)\n\n          const visualScene = library.visualScenes[skeleton];\n          const children = visualScene.children;\n          for (let j = 0; j < children.length; j++) {\n            const child = children[j];\n            if (child.type === 'JOINT') {\n              const root = getNode(child.id);\n              buildBoneHierarchy(root, joints, boneData);\n            }\n          }\n        } else {\n          console.error('THREE.ColladaLoader: Unable to find root bone of skeleton with ID:', skeleton);\n        }\n      }\n\n      // sort bone data (the order is defined in the corresponding controller)\n\n      for (i = 0; i < joints.length; i++) {\n        for (j = 0; j < boneData.length; j++) {\n          data = boneData[j];\n          if (data.bone.name === joints[i].name) {\n            sortedBoneData[i] = data;\n            data.processed = true;\n            break;\n          }\n        }\n      }\n\n      // add unprocessed bone data at the end of the list\n\n      for (i = 0; i < boneData.length; i++) {\n        data = boneData[i];\n        if (data.processed === false) {\n          sortedBoneData.push(data);\n          data.processed = true;\n        }\n      }\n\n      // setup arrays for skeleton creation\n\n      const bones = [];\n      const boneInverses = [];\n      for (i = 0; i < sortedBoneData.length; i++) {\n        data = sortedBoneData[i];\n        bones.push(data.bone);\n        boneInverses.push(data.boneInverse);\n      }\n      return new Skeleton(bones, boneInverses);\n    }\n    function buildBoneHierarchy(root, joints, boneData) {\n      // setup bone data from visual scene\n\n      root.traverse(function (object) {\n        if (object.isBone === true) {\n          let boneInverse;\n\n          // retrieve the boneInverse from the controller data\n\n          for (let i = 0; i < joints.length; i++) {\n            const joint = joints[i];\n            if (joint.name === object.name) {\n              boneInverse = joint.boneInverse;\n              break;\n            }\n          }\n          if (boneInverse === undefined) {\n            // Unfortunately, there can be joints in the visual scene that are not part of the\n            // corresponding controller. In this case, we have to create a dummy boneInverse matrix\n            // for the respective bone. This bone won't affect any vertices, because there are no skin indices\n            // and weights defined for it. But we still have to add the bone to the sorted bone list in order to\n            // ensure a correct animation of the model.\n\n            boneInverse = new Matrix4();\n          }\n          boneData.push({\n            bone: object,\n            boneInverse: boneInverse,\n            processed: false\n          });\n        }\n      });\n    }\n    function buildNode(data) {\n      const objects = [];\n      const matrix = data.matrix;\n      const nodes = data.nodes;\n      const type = data.type;\n      const instanceCameras = data.instanceCameras;\n      const instanceControllers = data.instanceControllers;\n      const instanceLights = data.instanceLights;\n      const instanceGeometries = data.instanceGeometries;\n      const instanceNodes = data.instanceNodes;\n\n      // nodes\n\n      for (let i = 0, l = nodes.length; i < l; i++) {\n        objects.push(getNode(nodes[i]));\n      }\n\n      // instance cameras\n\n      for (let i = 0, l = instanceCameras.length; i < l; i++) {\n        const instanceCamera = getCamera(instanceCameras[i]);\n        if (instanceCamera !== null) {\n          objects.push(instanceCamera.clone());\n        }\n      }\n\n      // instance controllers\n\n      for (let i = 0, l = instanceControllers.length; i < l; i++) {\n        const instance = instanceControllers[i];\n        const controller = getController(instance.id);\n        const geometries = getGeometry(controller.id);\n        const newObjects = buildObjects(geometries, instance.materials);\n        const skeletons = instance.skeletons;\n        const joints = controller.skin.joints;\n        const skeleton = buildSkeleton(skeletons, joints);\n        for (let j = 0, jl = newObjects.length; j < jl; j++) {\n          const object = newObjects[j];\n          if (object.isSkinnedMesh) {\n            object.bind(skeleton, controller.skin.bindMatrix);\n            object.normalizeSkinWeights();\n          }\n          objects.push(object);\n        }\n      }\n\n      // instance lights\n\n      for (let i = 0, l = instanceLights.length; i < l; i++) {\n        const instanceLight = getLight(instanceLights[i]);\n        if (instanceLight !== null) {\n          objects.push(instanceLight.clone());\n        }\n      }\n\n      // instance geometries\n\n      for (let i = 0, l = instanceGeometries.length; i < l; i++) {\n        const instance = instanceGeometries[i];\n\n        // a single geometry instance in collada can lead to multiple object3Ds.\n        // this is the case when primitives are combined like triangles and lines\n\n        const geometries = getGeometry(instance.id);\n        const newObjects = buildObjects(geometries, instance.materials);\n        for (let j = 0, jl = newObjects.length; j < jl; j++) {\n          objects.push(newObjects[j]);\n        }\n      }\n\n      // instance nodes\n\n      for (let i = 0, l = instanceNodes.length; i < l; i++) {\n        objects.push(getNode(instanceNodes[i]).clone());\n      }\n      let object;\n      if (nodes.length === 0 && objects.length === 1) {\n        object = objects[0];\n      } else {\n        object = type === 'JOINT' ? new Bone() : new Group();\n        for (let i = 0; i < objects.length; i++) {\n          object.add(objects[i]);\n        }\n      }\n      object.name = type === 'JOINT' ? data.sid : data.name;\n      object.matrix.copy(matrix);\n      object.matrix.decompose(object.position, object.quaternion, object.scale);\n      return object;\n    }\n    const fallbackMaterial = new MeshBasicMaterial({\n      color: 0xff00ff\n    });\n    function resolveMaterialBinding(keys, instanceMaterials) {\n      const materials = [];\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const id = instanceMaterials[keys[i]];\n        if (id === undefined) {\n          console.warn('THREE.ColladaLoader: Material with key %s not found. Apply fallback material.', keys[i]);\n          materials.push(fallbackMaterial);\n        } else {\n          materials.push(getMaterial(id));\n        }\n      }\n      return materials;\n    }\n    function buildObjects(geometries, instanceMaterials) {\n      const objects = [];\n      for (const type in geometries) {\n        const geometry = geometries[type];\n        const materials = resolveMaterialBinding(geometry.materialKeys, instanceMaterials);\n\n        // handle case if no materials are defined\n\n        if (materials.length === 0) {\n          if (type === 'lines' || type === 'linestrips') {\n            materials.push(new LineBasicMaterial());\n          } else {\n            materials.push(new MeshPhongMaterial());\n          }\n        }\n\n        // Collada allows to use phong and lambert materials with lines. Replacing these cases with LineBasicMaterial.\n\n        if (type === 'lines' || type === 'linestrips') {\n          for (let i = 0, l = materials.length; i < l; i++) {\n            const material = materials[i];\n            if (material.isMeshPhongMaterial === true || material.isMeshLambertMaterial === true) {\n              const lineMaterial = new LineBasicMaterial();\n\n              // copy compatible properties\n\n              lineMaterial.color.copy(material.color);\n              lineMaterial.opacity = material.opacity;\n              lineMaterial.transparent = material.transparent;\n\n              // replace material\n\n              materials[i] = lineMaterial;\n            }\n          }\n        }\n\n        // regard skinning\n\n        const skinning = geometry.data.attributes.skinIndex !== undefined;\n\n        // choose between a single or multi materials (material array)\n\n        const material = materials.length === 1 ? materials[0] : materials;\n\n        // now create a specific 3D object\n\n        let object;\n        switch (type) {\n          case 'lines':\n            object = new LineSegments(geometry.data, material);\n            break;\n          case 'linestrips':\n            object = new Line(geometry.data, material);\n            break;\n          case 'triangles':\n          case 'polylist':\n            if (skinning) {\n              object = new SkinnedMesh(geometry.data, material);\n            } else {\n              object = new Mesh(geometry.data, material);\n            }\n            break;\n        }\n        objects.push(object);\n      }\n      return objects;\n    }\n    function hasNode(id) {\n      return library.nodes[id] !== undefined;\n    }\n    function getNode(id) {\n      return getBuild(library.nodes[id], buildNode);\n    }\n\n    // visual scenes\n\n    function parseVisualScene(xml) {\n      const data = {\n        name: xml.getAttribute('name'),\n        children: []\n      };\n      prepareNodes(xml);\n      const elements = getElementsByTagName(xml, 'node');\n      for (let i = 0; i < elements.length; i++) {\n        data.children.push(parseNode(elements[i]));\n      }\n      library.visualScenes[xml.getAttribute('id')] = data;\n    }\n    function buildVisualScene(data) {\n      const group = new Group();\n      group.name = data.name;\n      const children = data.children;\n      for (let i = 0; i < children.length; i++) {\n        const child = children[i];\n        group.add(getNode(child.id));\n      }\n      return group;\n    }\n    function hasVisualScene(id) {\n      return library.visualScenes[id] !== undefined;\n    }\n    function getVisualScene(id) {\n      return getBuild(library.visualScenes[id], buildVisualScene);\n    }\n\n    // scenes\n\n    function parseScene(xml) {\n      const instance = getElementsByTagName(xml, 'instance_visual_scene')[0];\n      return getVisualScene(parseId(instance.getAttribute('url')));\n    }\n    function setupAnimations() {\n      const clips = library.clips;\n      if (isEmpty(clips) === true) {\n        if (isEmpty(library.animations) === false) {\n          // if there are animations but no clips, we create a default clip for playback\n\n          const tracks = [];\n          for (const id in library.animations) {\n            const animationTracks = getAnimation(id);\n            for (let i = 0, l = animationTracks.length; i < l; i++) {\n              tracks.push(animationTracks[i]);\n            }\n          }\n          animations.push(new AnimationClip('default', -1, tracks));\n        }\n      } else {\n        for (const id in clips) {\n          animations.push(getAnimationClip(id));\n        }\n      }\n    }\n\n    // convert the parser error element into text with each child elements text\n    // separated by new lines.\n\n    function parserErrorToText(parserError) {\n      let result = '';\n      const stack = [parserError];\n      while (stack.length) {\n        const node = stack.shift();\n        if (node.nodeType === Node.TEXT_NODE) {\n          result += node.textContent;\n        } else {\n          result += '\\n';\n          stack.push.apply(stack, node.childNodes);\n        }\n      }\n      return result.trim();\n    }\n    if (text.length === 0) {\n      return {\n        scene: new Scene()\n      };\n    }\n    const xml = new DOMParser().parseFromString(text, 'application/xml');\n    const collada = getElementsByTagName(xml, 'COLLADA')[0];\n    const parserError = xml.getElementsByTagName('parsererror')[0];\n    if (parserError !== undefined) {\n      // Chrome will return parser error with a div in it\n\n      const errorElement = getElementsByTagName(parserError, 'div')[0];\n      let errorText;\n      if (errorElement) {\n        errorText = errorElement.textContent;\n      } else {\n        errorText = parserErrorToText(parserError);\n      }\n      console.error('THREE.ColladaLoader: Failed to parse collada file.\\n', errorText);\n      return null;\n    }\n\n    // metadata\n\n    const version = collada.getAttribute('version');\n    console.debug('THREE.ColladaLoader: File version', version);\n    const asset = parseAsset(getElementsByTagName(collada, 'asset')[0]);\n    const textureLoader = new TextureLoader(this.manager);\n    textureLoader.setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n    let tgaLoader;\n    if (TGALoader) {\n      tgaLoader = new TGALoader(this.manager);\n      tgaLoader.setPath(this.resourcePath || path);\n    }\n\n    //\n\n    const tempColor = new Color();\n    const animations = [];\n    let kinematics = {};\n    let count = 0;\n\n    //\n\n    const library = {\n      animations: {},\n      clips: {},\n      controllers: {},\n      images: {},\n      effects: {},\n      materials: {},\n      cameras: {},\n      lights: {},\n      geometries: {},\n      nodes: {},\n      visualScenes: {},\n      kinematicsModels: {},\n      physicsModels: {},\n      kinematicsScenes: {}\n    };\n    parseLibrary(collada, 'library_animations', 'animation', parseAnimation);\n    parseLibrary(collada, 'library_animation_clips', 'animation_clip', parseAnimationClip);\n    parseLibrary(collada, 'library_controllers', 'controller', parseController);\n    parseLibrary(collada, 'library_images', 'image', parseImage);\n    parseLibrary(collada, 'library_effects', 'effect', parseEffect);\n    parseLibrary(collada, 'library_materials', 'material', parseMaterial);\n    parseLibrary(collada, 'library_cameras', 'camera', parseCamera);\n    parseLibrary(collada, 'library_lights', 'light', parseLight);\n    parseLibrary(collada, 'library_geometries', 'geometry', parseGeometry);\n    parseLibrary(collada, 'library_nodes', 'node', parseNode);\n    parseLibrary(collada, 'library_visual_scenes', 'visual_scene', parseVisualScene);\n    parseLibrary(collada, 'library_kinematics_models', 'kinematics_model', parseKinematicsModel);\n    parseLibrary(collada, 'library_physics_models', 'physics_model', parsePhysicsModel);\n    parseLibrary(collada, 'scene', 'instance_kinematics_scene', parseKinematicsScene);\n    buildLibrary(library.animations, buildAnimation);\n    buildLibrary(library.clips, buildAnimationClip);\n    buildLibrary(library.controllers, buildController);\n    buildLibrary(library.images, buildImage);\n    buildLibrary(library.effects, buildEffect);\n    buildLibrary(library.materials, buildMaterial);\n    buildLibrary(library.cameras, buildCamera);\n    buildLibrary(library.lights, buildLight);\n    buildLibrary(library.geometries, buildGeometry);\n    buildLibrary(library.visualScenes, buildVisualScene);\n    setupAnimations();\n    setupKinematics();\n    const scene = parseScene(getElementsByTagName(collada, 'scene')[0]);\n    scene.animations = animations;\n    if (asset.upAxis === 'Z_UP') {\n      console.warn('THREE.ColladaLoader: You are loading an asset with a Z-UP coordinate system. The loader just rotates the asset to transform it into Y-UP. The vertex data are not converted, see #24289.');\n      scene.rotation.set(-Math.PI / 2, 0, 0);\n    }\n    scene.scale.multiplyScalar(asset.unit);\n    return {\n      get animations() {\n        console.warn('THREE.ColladaLoader: Please access animations over scene.animations now.');\n        return animations;\n      },\n      kinematics: kinematics,\n      library: library,\n      scene: scene\n    };\n  }\n}\nexport { ColladaLoader };","map":{"version":3,"names":["AmbientLight","AnimationClip","Bone","BufferGeometry","ClampToEdgeWrapping","Color","DirectionalLight","DoubleSide","FileLoader","Float32BufferAttribute","FrontSide","Group","Line","LineBasicMaterial","LineSegments","Loader","LoaderUtils","MathUtils","Matrix4","Mesh","MeshBasicMaterial","MeshLambertMaterial","MeshPhongMaterial","OrthographicCamera","PerspectiveCamera","PointLight","Quaternion","QuaternionKeyframeTrack","RepeatWrapping","Scene","Skeleton","SkinnedMesh","SpotLight","TextureLoader","Vector2","Vector3","VectorKeyframeTrack","sRGBEncoding","TGALoader","ColladaLoader","constructor","manager","load","url","onLoad","onProgress","onError","scope","path","extractUrlBase","loader","setPath","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","getElementsByTagName","xml","name","array","childNodes","i","l","length","child","nodeName","push","parseStrings","parts","trim","split","Array","parseFloats","parseFloat","parseInts","parseInt","parseId","substring","generateId","count","isEmpty","object","Object","keys","parseAsset","unit","parseAssetUnit","upAxis","parseAssetUpAxis","undefined","hasAttribute","getAttribute","textContent","parseLibrary","libraryName","parser","library","elements","buildLibrary","data","builder","build","getBuild","parseAnimation","sources","samplers","channels","hasChildren","nodeType","id","parseSource","parseAnimationSampler","parseAnimationChannel","log","animations","generateUUID","inputs","semantic","target","shift","sid","arraySyntax","indexOf","memberSyntax","member","indices","replace","sampler","buildAnimation","tracks","hasOwnProperty","channel","inputId","INPUT","outputId","OUTPUT","inputSource","outputSource","animation","buildAnimationChannel","createKeyframeTracks","getAnimation","node","nodes","object3D","getNode","transform","transforms","defaultMatrix","matrix","clone","transpose","time","stride","il","j","jl","value","index","warn","keyframes","prepareAnimationData","uuid","sort","ascending","transformAnimationData","a","b","position","scale","quaternion","times","positionData","quaternionData","scaleData","keyframe","fromArray","decompose","x","y","z","w","property","defaultValue","empty","createMissingKeyframes","prev","next","getPrev","getNext","interpolate","key","parseAnimationClip","start","end","clips","buildAnimationClip","duration","animationTracks","getAnimationClip","parseController","skin","parseSkin","controllers","bindShapeMatrix","joints","parseJoints","vertexWeights","parseVertexWeights","offset","vcount","v","buildController","geometry","geometries","buildSkin","skinIndices","skinWeights","weights","BONE_LIMIT","jointOffset","JOINT","weightOffset","WEIGHT","jointSource","inverseSource","INV_BIND_MATRIX","jointCount","vertexSkinData","skinIndex","weightId","skinWeight","weight","descending","d","bindMatrix","identity","boneInverse","getController","parseImage","init_from","images","buildImage","getImage","parseEffect","profile","parseEffectProfileCOMMON","effects","surfaces","parseEffectNewparam","technique","parseEffectTechnique","extra","parseEffectExtra","parseEffectSurface","parseEffectSampler","source","type","parameters","parseEffectParameters","parseEffectParameter","opaque","parseEffectParameterTexture","parseEffectParameterTextureExtra","parseEffectParameterTextureExtraTechnique","toUpperCase","parseEffectExtraTechniqueBump","parseEffectExtraTechnique","texcoord","buildEffect","getEffect","parseMaterial","materials","getTextureLoader","image","extension","slice","lastIndexOf","toLowerCase","tgaLoader","textureLoader","buildMaterial","effect","material","getTexture","textureObject","encoding","arguments","surface","texture","wrapS","wrapU","wrapT","wrapV","set","offsetU","offsetV","repeat","repeatU","repeatV","parameter","color","map","specular","specularMap","normalMap","lightMap","float","shininess","emissive","emissiveMap","convertSRGBToLinear","transparent","transparency","opacity","techniques","k","side","normalScale","getMaterial","parseCamera","optics","parseCameraOptics","cameras","parseCameraTechnique","parseCameraParameters","buildCamera","camera","yfov","aspect_ratio","znear","zfar","ymag","xmag","aspectRatio","getCamera","parseLight","parseLightTechnique","lights","parseLightParameters","falloffAngle","f","distance","Math","sqrt","buildLight","light","copy","getLight","parseGeometry","vertices","primitives","mesh","parseGeometryVertices","parseGeometryPrimitive","accessor","primitive","hasUV","inputname","max","p","groupPrimitives","checkUVCoordinates","uvsNeedsFix","buildGeometry","groupedPrimitives","primitiveType","buildGeometryType","normal","uv","uv2","materialKeys","g","vc","addGroup","input","prevLength","buildGeometryData","setAttribute","isColor","pushVector","sourceStride","sourceArray","startIndex","tempColor","setRGB","r","c","kl","getGeometry","parseKinematicsModel","links","parseKinematicsTechniqueCommon","kinematicsModels","buildKinematicsModel","getKinematicsModel","parseKinematicsJoint","parseKinematicsLink","parseKinematicsJointParameter","axis","limits","min","static","zeroPosition","middlePosition","attachments","parseKinematicsAttachment","parseKinematicsTransform","joint","pop","obj","angle","degToRad","parsePhysicsModel","rigidBodies","parsePhysicsRigidBody","physicsModels","parsePhysicsTechniqueCommon","inertia","mass","parseKinematicsScene","bindJointAxis","parseKinematicsBindJointAxis","kinematicsScenes","param","tmpJointIndex","jointIndex","buildKinematicsScene","getKinematicsScene","setupKinematics","kinematicsModelId","kinematicsSceneId","visualSceneId","visualScenes","kinematicsModel","kinematicsScene","visualScene","getVisualScene","jointMap","targetElement","collada","querySelector","parentVisualElement","parentElement","connect","visualElement","visualElementName","traverse","buildTransformList","m0","kinematics","getJointValue","jointData","setJointValue","multiply","makeRotationAxis","makeTranslation","vector","prepareNodes","element","parseNode","instanceCameras","instanceControllers","instanceLights","instanceGeometries","instanceNodes","parseNodeInstance","hasNode","skeletons","instances","instance","symbol","buildSkeleton","boneData","sortedBoneData","skeleton","root","buildBoneHierarchy","hasVisualScene","children","bone","processed","bones","boneInverses","isBone","buildNode","objects","instanceCamera","controller","newObjects","buildObjects","isSkinnedMesh","bind","normalizeSkinWeights","instanceLight","add","fallbackMaterial","resolveMaterialBinding","instanceMaterials","isMeshPhongMaterial","isMeshLambertMaterial","lineMaterial","skinning","attributes","parseVisualScene","buildVisualScene","group","parseScene","setupAnimations","parserErrorToText","parserError","result","stack","Node","TEXT_NODE","apply","scene","DOMParser","parseFromString","errorElement","errorText","version","debug","asset","resourcePath","setCrossOrigin","crossOrigin","rotation","PI","multiplyScalar"],"sources":["/Users/nicolas/Documents/pose-creator/node_modules/three/examples/jsm/loaders/ColladaLoader.js"],"sourcesContent":["import {\n\tAmbientLight,\n\tAnimationClip,\n\tBone,\n\tBufferGeometry,\n\tClampToEdgeWrapping,\n\tColor,\n\tDirectionalLight,\n\tDoubleSide,\n\tFileLoader,\n\tFloat32BufferAttribute,\n\tFrontSide,\n\tGroup,\n\tLine,\n\tLineBasicMaterial,\n\tLineSegments,\n\tLoader,\n\tLoaderUtils,\n\tMathUtils,\n\tMatrix4,\n\tMesh,\n\tMeshBasicMaterial,\n\tMeshLambertMaterial,\n\tMeshPhongMaterial,\n\tOrthographicCamera,\n\tPerspectiveCamera,\n\tPointLight,\n\tQuaternion,\n\tQuaternionKeyframeTrack,\n\tRepeatWrapping,\n\tScene,\n\tSkeleton,\n\tSkinnedMesh,\n\tSpotLight,\n\tTextureLoader,\n\tVector2,\n\tVector3,\n\tVectorKeyframeTrack,\n\tsRGBEncoding\n} from 'three';\nimport { TGALoader } from '../loaders/TGALoader.js';\n\nclass ColladaLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst path = ( scope.path === '' ) ? LoaderUtils.extractUrlBase( url ) : scope.path;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text, path ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( text, path ) {\n\n\t\tfunction getElementsByTagName( xml, name ) {\n\n\t\t\t// Non recursive xml.getElementsByTagName() ...\n\n\t\t\tconst array = [];\n\t\t\tconst childNodes = xml.childNodes;\n\n\t\t\tfor ( let i = 0, l = childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = childNodes[ i ];\n\n\t\t\t\tif ( child.nodeName === name ) {\n\n\t\t\t\t\tarray.push( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tfunction parseStrings( text ) {\n\n\t\t\tif ( text.length === 0 ) return [];\n\n\t\t\tconst parts = text.trim().split( /\\s+/ );\n\t\t\tconst array = new Array( parts.length );\n\n\t\t\tfor ( let i = 0, l = parts.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ] = parts[ i ];\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tfunction parseFloats( text ) {\n\n\t\t\tif ( text.length === 0 ) return [];\n\n\t\t\tconst parts = text.trim().split( /\\s+/ );\n\t\t\tconst array = new Array( parts.length );\n\n\t\t\tfor ( let i = 0, l = parts.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ] = parseFloat( parts[ i ] );\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tfunction parseInts( text ) {\n\n\t\t\tif ( text.length === 0 ) return [];\n\n\t\t\tconst parts = text.trim().split( /\\s+/ );\n\t\t\tconst array = new Array( parts.length );\n\n\t\t\tfor ( let i = 0, l = parts.length; i < l; i ++ ) {\n\n\t\t\t\tarray[ i ] = parseInt( parts[ i ] );\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\t\t}\n\n\t\tfunction parseId( text ) {\n\n\t\t\treturn text.substring( 1 );\n\n\t\t}\n\n\t\tfunction generateId() {\n\n\t\t\treturn 'three_default_' + ( count ++ );\n\n\t\t}\n\n\t\tfunction isEmpty( object ) {\n\n\t\t\treturn Object.keys( object ).length === 0;\n\n\t\t}\n\n\t\t// asset\n\n\t\tfunction parseAsset( xml ) {\n\n\t\t\treturn {\n\t\t\t\tunit: parseAssetUnit( getElementsByTagName( xml, 'unit' )[ 0 ] ),\n\t\t\t\tupAxis: parseAssetUpAxis( getElementsByTagName( xml, 'up_axis' )[ 0 ] )\n\t\t\t};\n\n\t\t}\n\n\t\tfunction parseAssetUnit( xml ) {\n\n\t\t\tif ( ( xml !== undefined ) && ( xml.hasAttribute( 'meter' ) === true ) ) {\n\n\t\t\t\treturn parseFloat( xml.getAttribute( 'meter' ) );\n\n\t\t\t} else {\n\n\t\t\t\treturn 1; // default 1 meter\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseAssetUpAxis( xml ) {\n\n\t\t\treturn xml !== undefined ? xml.textContent : 'Y_UP';\n\n\t\t}\n\n\t\t// library\n\n\t\tfunction parseLibrary( xml, libraryName, nodeName, parser ) {\n\n\t\t\tconst library = getElementsByTagName( xml, libraryName )[ 0 ];\n\n\t\t\tif ( library !== undefined ) {\n\n\t\t\t\tconst elements = getElementsByTagName( library, nodeName );\n\n\t\t\t\tfor ( let i = 0; i < elements.length; i ++ ) {\n\n\t\t\t\t\tparser( elements[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction buildLibrary( data, builder ) {\n\n\t\t\tfor ( const name in data ) {\n\n\t\t\t\tconst object = data[ name ];\n\t\t\t\tobject.build = builder( data[ name ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// get\n\n\t\tfunction getBuild( data, builder ) {\n\n\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\tdata.build = builder( data );\n\n\t\t\treturn data.build;\n\n\t\t}\n\n\t\t// animation\n\n\t\tfunction parseAnimation( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tsources: {},\n\t\t\t\tsamplers: {},\n\t\t\t\tchannels: {}\n\t\t\t};\n\n\t\t\tlet hasChildren = false;\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tlet id;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tid = child.getAttribute( 'id' );\n\t\t\t\t\t\tdata.sources[ id ] = parseSource( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'sampler':\n\t\t\t\t\t\tid = child.getAttribute( 'id' );\n\t\t\t\t\t\tdata.samplers[ id ] = parseAnimationSampler( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'channel':\n\t\t\t\t\t\tid = child.getAttribute( 'target' );\n\t\t\t\t\t\tdata.channels[ id ] = parseAnimationChannel( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'animation':\n\t\t\t\t\t\t// hierarchy of related animations\n\t\t\t\t\t\tparseAnimation( child );\n\t\t\t\t\t\thasChildren = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.log( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasChildren === false ) {\n\n\t\t\t\t// since 'id' attributes can be optional, it's necessary to generate a UUID for unqiue assignment\n\n\t\t\t\tlibrary.animations[ xml.getAttribute( 'id' ) || MathUtils.generateUUID() ] = data;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseAnimationSampler( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tinputs: {},\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tconst id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tconst semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\tdata.inputs[ semantic ] = id;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseAnimationChannel( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tconst target = xml.getAttribute( 'target' );\n\n\t\t\t// parsing SID Addressing Syntax\n\n\t\t\tlet parts = target.split( '/' );\n\n\t\t\tconst id = parts.shift();\n\t\t\tlet sid = parts.shift();\n\n\t\t\t// check selection syntax\n\n\t\t\tconst arraySyntax = ( sid.indexOf( '(' ) !== - 1 );\n\t\t\tconst memberSyntax = ( sid.indexOf( '.' ) !== - 1 );\n\n\t\t\tif ( memberSyntax ) {\n\n\t\t\t\t//  member selection access\n\n\t\t\t\tparts = sid.split( '.' );\n\t\t\t\tsid = parts.shift();\n\t\t\t\tdata.member = parts.shift();\n\n\t\t\t} else if ( arraySyntax ) {\n\n\t\t\t\t// array-access syntax. can be used to express fields in one-dimensional vectors or two-dimensional matrices.\n\n\t\t\t\tconst indices = sid.split( '(' );\n\t\t\t\tsid = indices.shift();\n\n\t\t\t\tfor ( let i = 0; i < indices.length; i ++ ) {\n\n\t\t\t\t\tindices[ i ] = parseInt( indices[ i ].replace( /\\)/, '' ) );\n\n\t\t\t\t}\n\n\t\t\t\tdata.indices = indices;\n\n\t\t\t}\n\n\t\t\tdata.id = id;\n\t\t\tdata.sid = sid;\n\n\t\t\tdata.arraySyntax = arraySyntax;\n\t\t\tdata.memberSyntax = memberSyntax;\n\n\t\t\tdata.sampler = parseId( xml.getAttribute( 'source' ) );\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildAnimation( data ) {\n\n\t\t\tconst tracks = [];\n\n\t\t\tconst channels = data.channels;\n\t\t\tconst samplers = data.samplers;\n\t\t\tconst sources = data.sources;\n\n\t\t\tfor ( const target in channels ) {\n\n\t\t\t\tif ( channels.hasOwnProperty( target ) ) {\n\n\t\t\t\t\tconst channel = channels[ target ];\n\t\t\t\t\tconst sampler = samplers[ channel.sampler ];\n\n\t\t\t\t\tconst inputId = sampler.inputs.INPUT;\n\t\t\t\t\tconst outputId = sampler.inputs.OUTPUT;\n\n\t\t\t\t\tconst inputSource = sources[ inputId ];\n\t\t\t\t\tconst outputSource = sources[ outputId ];\n\n\t\t\t\t\tconst animation = buildAnimationChannel( channel, inputSource, outputSource );\n\n\t\t\t\t\tcreateKeyframeTracks( animation, tracks );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn tracks;\n\n\t\t}\n\n\t\tfunction getAnimation( id ) {\n\n\t\t\treturn getBuild( library.animations[ id ], buildAnimation );\n\n\t\t}\n\n\t\tfunction buildAnimationChannel( channel, inputSource, outputSource ) {\n\n\t\t\tconst node = library.nodes[ channel.id ];\n\t\t\tconst object3D = getNode( node.id );\n\n\t\t\tconst transform = node.transforms[ channel.sid ];\n\t\t\tconst defaultMatrix = node.matrix.clone().transpose();\n\n\t\t\tlet time, stride;\n\t\t\tlet i, il, j, jl;\n\n\t\t\tconst data = {};\n\n\t\t\t// the collada spec allows the animation of data in various ways.\n\t\t\t// depending on the transform type (matrix, translate, rotate, scale), we execute different logic\n\n\t\t\tswitch ( transform ) {\n\n\t\t\t\tcase 'matrix':\n\n\t\t\t\t\tfor ( i = 0, il = inputSource.array.length; i < il; i ++ ) {\n\n\t\t\t\t\t\ttime = inputSource.array[ i ];\n\t\t\t\t\t\tstride = i * outputSource.stride;\n\n\t\t\t\t\t\tif ( data[ time ] === undefined ) data[ time ] = {};\n\n\t\t\t\t\t\tif ( channel.arraySyntax === true ) {\n\n\t\t\t\t\t\t\tconst value = outputSource.array[ stride ];\n\t\t\t\t\t\t\tconst index = channel.indices[ 0 ] + 4 * channel.indices[ 1 ];\n\n\t\t\t\t\t\t\tdata[ time ][ index ] = value;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tfor ( j = 0, jl = outputSource.stride; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\t\tdata[ time ][ j ] = outputSource.array[ stride + j ];\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'translate':\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rotate':\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'scale':\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Animation transform type \"%s\" not yet implemented.', transform );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tconst keyframes = prepareAnimationData( data, defaultMatrix );\n\n\t\t\tconst animation = {\n\t\t\t\tname: object3D.uuid,\n\t\t\t\tkeyframes: keyframes\n\t\t\t};\n\n\t\t\treturn animation;\n\n\t\t}\n\n\t\tfunction prepareAnimationData( data, defaultMatrix ) {\n\n\t\t\tconst keyframes = [];\n\n\t\t\t// transfer data into a sortable array\n\n\t\t\tfor ( const time in data ) {\n\n\t\t\t\tkeyframes.push( { time: parseFloat( time ), value: data[ time ] } );\n\n\t\t\t}\n\n\t\t\t// ensure keyframes are sorted by time\n\n\t\t\tkeyframes.sort( ascending );\n\n\t\t\t// now we clean up all animation data, so we can use them for keyframe tracks\n\n\t\t\tfor ( let i = 0; i < 16; i ++ ) {\n\n\t\t\t\ttransformAnimationData( keyframes, i, defaultMatrix.elements[ i ] );\n\n\t\t\t}\n\n\t\t\treturn keyframes;\n\n\t\t\t// array sort function\n\n\t\t\tfunction ascending( a, b ) {\n\n\t\t\t\treturn a.time - b.time;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst position = new Vector3();\n\t\tconst scale = new Vector3();\n\t\tconst quaternion = new Quaternion();\n\n\t\tfunction createKeyframeTracks( animation, tracks ) {\n\n\t\t\tconst keyframes = animation.keyframes;\n\t\t\tconst name = animation.name;\n\n\t\t\tconst times = [];\n\t\t\tconst positionData = [];\n\t\t\tconst quaternionData = [];\n\t\t\tconst scaleData = [];\n\n\t\t\tfor ( let i = 0, l = keyframes.length; i < l; i ++ ) {\n\n\t\t\t\tconst keyframe = keyframes[ i ];\n\n\t\t\t\tconst time = keyframe.time;\n\t\t\t\tconst value = keyframe.value;\n\n\t\t\t\tmatrix.fromArray( value ).transpose();\n\t\t\t\tmatrix.decompose( position, quaternion, scale );\n\n\t\t\t\ttimes.push( time );\n\t\t\t\tpositionData.push( position.x, position.y, position.z );\n\t\t\t\tquaternionData.push( quaternion.x, quaternion.y, quaternion.z, quaternion.w );\n\t\t\t\tscaleData.push( scale.x, scale.y, scale.z );\n\n\t\t\t}\n\n\t\t\tif ( positionData.length > 0 ) tracks.push( new VectorKeyframeTrack( name + '.position', times, positionData ) );\n\t\t\tif ( quaternionData.length > 0 ) tracks.push( new QuaternionKeyframeTrack( name + '.quaternion', times, quaternionData ) );\n\t\t\tif ( scaleData.length > 0 ) tracks.push( new VectorKeyframeTrack( name + '.scale', times, scaleData ) );\n\n\t\t\treturn tracks;\n\n\t\t}\n\n\t\tfunction transformAnimationData( keyframes, property, defaultValue ) {\n\n\t\t\tlet keyframe;\n\n\t\t\tlet empty = true;\n\t\t\tlet i, l;\n\n\t\t\t// check, if values of a property are missing in our keyframes\n\n\t\t\tfor ( i = 0, l = keyframes.length; i < l; i ++ ) {\n\n\t\t\t\tkeyframe = keyframes[ i ];\n\n\t\t\t\tif ( keyframe.value[ property ] === undefined ) {\n\n\t\t\t\t\tkeyframe.value[ property ] = null; // mark as missing\n\n\t\t\t\t} else {\n\n\t\t\t\t\tempty = false;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( empty === true ) {\n\n\t\t\t\t// no values at all, so we set a default value\n\n\t\t\t\tfor ( i = 0, l = keyframes.length; i < l; i ++ ) {\n\n\t\t\t\t\tkeyframe = keyframes[ i ];\n\n\t\t\t\t\tkeyframe.value[ property ] = defaultValue;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// filling gaps\n\n\t\t\t\tcreateMissingKeyframes( keyframes, property );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction createMissingKeyframes( keyframes, property ) {\n\n\t\t\tlet prev, next;\n\n\t\t\tfor ( let i = 0, l = keyframes.length; i < l; i ++ ) {\n\n\t\t\t\tconst keyframe = keyframes[ i ];\n\n\t\t\t\tif ( keyframe.value[ property ] === null ) {\n\n\t\t\t\t\tprev = getPrev( keyframes, i, property );\n\t\t\t\t\tnext = getNext( keyframes, i, property );\n\n\t\t\t\t\tif ( prev === null ) {\n\n\t\t\t\t\t\tkeyframe.value[ property ] = next.value[ property ];\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( next === null ) {\n\n\t\t\t\t\t\tkeyframe.value[ property ] = prev.value[ property ];\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tinterpolate( keyframe, prev, next, property );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getPrev( keyframes, i, property ) {\n\n\t\t\twhile ( i >= 0 ) {\n\n\t\t\t\tconst keyframe = keyframes[ i ];\n\n\t\t\t\tif ( keyframe.value[ property ] !== null ) return keyframe;\n\n\t\t\t\ti --;\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfunction getNext( keyframes, i, property ) {\n\n\t\t\twhile ( i < keyframes.length ) {\n\n\t\t\t\tconst keyframe = keyframes[ i ];\n\n\t\t\t\tif ( keyframe.value[ property ] !== null ) return keyframe;\n\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfunction interpolate( key, prev, next, property ) {\n\n\t\t\tif ( ( next.time - prev.time ) === 0 ) {\n\n\t\t\t\tkey.value[ property ] = prev.value[ property ];\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tkey.value[ property ] = ( ( key.time - prev.time ) * ( next.value[ property ] - prev.value[ property ] ) / ( next.time - prev.time ) ) + prev.value[ property ];\n\n\t\t}\n\n\t\t// animation clips\n\n\t\tfunction parseAnimationClip( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'id' ) || 'default',\n\t\t\t\tstart: parseFloat( xml.getAttribute( 'start' ) || 0 ),\n\t\t\t\tend: parseFloat( xml.getAttribute( 'end' ) || 0 ),\n\t\t\t\tanimations: []\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'instance_animation':\n\t\t\t\t\t\tdata.animations.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.clips[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction buildAnimationClip( data ) {\n\n\t\t\tconst tracks = [];\n\n\t\t\tconst name = data.name;\n\t\t\tconst duration = ( data.end - data.start ) || - 1;\n\t\t\tconst animations = data.animations;\n\n\t\t\tfor ( let i = 0, il = animations.length; i < il; i ++ ) {\n\n\t\t\t\tconst animationTracks = getAnimation( animations[ i ] );\n\n\t\t\t\tfor ( let j = 0, jl = animationTracks.length; j < jl; j ++ ) {\n\n\t\t\t\t\ttracks.push( animationTracks[ j ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new AnimationClip( name, duration, tracks );\n\n\t\t}\n\n\t\tfunction getAnimationClip( id ) {\n\n\t\t\treturn getBuild( library.clips[ id ], buildAnimationClip );\n\n\t\t}\n\n\t\t// controller\n\n\t\tfunction parseController( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'skin':\n\t\t\t\t\t\t// there is exactly one skin per controller\n\t\t\t\t\t\tdata.id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tdata.skin = parseSkin( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'morph':\n\t\t\t\t\t\tdata.id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Morph target animation not supported yet.' );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.controllers[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseSkin( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tsources: {}\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'bind_shape_matrix':\n\t\t\t\t\t\tdata.bindShapeMatrix = parseFloats( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tconst id = child.getAttribute( 'id' );\n\t\t\t\t\t\tdata.sources[ id ] = parseSource( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'joints':\n\t\t\t\t\t\tdata.joints = parseJoints( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'vertex_weights':\n\t\t\t\t\t\tdata.vertexWeights = parseVertexWeights( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseJoints( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tinputs: {}\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tconst semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\tconst id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tdata.inputs[ semantic ] = id;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseVertexWeights( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tinputs: {}\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tconst semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\tconst id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tconst offset = parseInt( child.getAttribute( 'offset' ) );\n\t\t\t\t\t\tdata.inputs[ semantic ] = { id: id, offset: offset };\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'vcount':\n\t\t\t\t\t\tdata.vcount = parseInts( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\tdata.v = parseInts( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildController( data ) {\n\n\t\t\tconst build = {\n\t\t\t\tid: data.id\n\t\t\t};\n\n\t\t\tconst geometry = library.geometries[ build.id ];\n\n\t\t\tif ( data.skin !== undefined ) {\n\n\t\t\t\tbuild.skin = buildSkin( data.skin );\n\n\t\t\t\t// we enhance the 'sources' property of the corresponding geometry with our skin data\n\n\t\t\t\tgeometry.sources.skinIndices = build.skin.indices;\n\t\t\t\tgeometry.sources.skinWeights = build.skin.weights;\n\n\t\t\t}\n\n\t\t\treturn build;\n\n\t\t}\n\n\t\tfunction buildSkin( data ) {\n\n\t\t\tconst BONE_LIMIT = 4;\n\n\t\t\tconst build = {\n\t\t\t\tjoints: [], // this must be an array to preserve the joint order\n\t\t\t\tindices: {\n\t\t\t\t\tarray: [],\n\t\t\t\t\tstride: BONE_LIMIT\n\t\t\t\t},\n\t\t\t\tweights: {\n\t\t\t\t\tarray: [],\n\t\t\t\t\tstride: BONE_LIMIT\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tconst sources = data.sources;\n\t\t\tconst vertexWeights = data.vertexWeights;\n\n\t\t\tconst vcount = vertexWeights.vcount;\n\t\t\tconst v = vertexWeights.v;\n\t\t\tconst jointOffset = vertexWeights.inputs.JOINT.offset;\n\t\t\tconst weightOffset = vertexWeights.inputs.WEIGHT.offset;\n\n\t\t\tconst jointSource = data.sources[ data.joints.inputs.JOINT ];\n\t\t\tconst inverseSource = data.sources[ data.joints.inputs.INV_BIND_MATRIX ];\n\n\t\t\tconst weights = sources[ vertexWeights.inputs.WEIGHT.id ].array;\n\t\t\tlet stride = 0;\n\n\t\t\tlet i, j, l;\n\n\t\t\t// procces skin data for each vertex\n\n\t\t\tfor ( i = 0, l = vcount.length; i < l; i ++ ) {\n\n\t\t\t\tconst jointCount = vcount[ i ]; // this is the amount of joints that affect a single vertex\n\t\t\t\tconst vertexSkinData = [];\n\n\t\t\t\tfor ( j = 0; j < jointCount; j ++ ) {\n\n\t\t\t\t\tconst skinIndex = v[ stride + jointOffset ];\n\t\t\t\t\tconst weightId = v[ stride + weightOffset ];\n\t\t\t\t\tconst skinWeight = weights[ weightId ];\n\n\t\t\t\t\tvertexSkinData.push( { index: skinIndex, weight: skinWeight } );\n\n\t\t\t\t\tstride += 2;\n\n\t\t\t\t}\n\n\t\t\t\t// we sort the joints in descending order based on the weights.\n\t\t\t\t// this ensures, we only procced the most important joints of the vertex\n\n\t\t\t\tvertexSkinData.sort( descending );\n\n\t\t\t\t// now we provide for each vertex a set of four index and weight values.\n\t\t\t\t// the order of the skin data matches the order of vertices\n\n\t\t\t\tfor ( j = 0; j < BONE_LIMIT; j ++ ) {\n\n\t\t\t\t\tconst d = vertexSkinData[ j ];\n\n\t\t\t\t\tif ( d !== undefined ) {\n\n\t\t\t\t\t\tbuild.indices.array.push( d.index );\n\t\t\t\t\t\tbuild.weights.array.push( d.weight );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tbuild.indices.array.push( 0 );\n\t\t\t\t\t\tbuild.weights.array.push( 0 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// setup bind matrix\n\n\t\t\tif ( data.bindShapeMatrix ) {\n\n\t\t\t\tbuild.bindMatrix = new Matrix4().fromArray( data.bindShapeMatrix ).transpose();\n\n\t\t\t} else {\n\n\t\t\t\tbuild.bindMatrix = new Matrix4().identity();\n\n\t\t\t}\n\n\t\t\t// process bones and inverse bind matrix data\n\n\t\t\tfor ( i = 0, l = jointSource.array.length; i < l; i ++ ) {\n\n\t\t\t\tconst name = jointSource.array[ i ];\n\t\t\t\tconst boneInverse = new Matrix4().fromArray( inverseSource.array, i * inverseSource.stride ).transpose();\n\n\t\t\t\tbuild.joints.push( { name: name, boneInverse: boneInverse } );\n\n\t\t\t}\n\n\t\t\treturn build;\n\n\t\t\t// array sort function\n\n\t\t\tfunction descending( a, b ) {\n\n\t\t\t\treturn b.weight - a.weight;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getController( id ) {\n\n\t\t\treturn getBuild( library.controllers[ id ], buildController );\n\n\t\t}\n\n\t\t// image\n\n\t\tfunction parseImage( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tinit_from: getElementsByTagName( xml, 'init_from' )[ 0 ].textContent\n\t\t\t};\n\n\t\t\tlibrary.images[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction buildImage( data ) {\n\n\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\treturn data.init_from;\n\n\t\t}\n\n\t\tfunction getImage( id ) {\n\n\t\t\tconst data = library.images[ id ];\n\n\t\t\tif ( data !== undefined ) {\n\n\t\t\t\treturn getBuild( data, buildImage );\n\n\t\t\t}\n\n\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t find image with ID:', id );\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// effect\n\n\t\tfunction parseEffect( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'profile_COMMON':\n\t\t\t\t\t\tdata.profile = parseEffectProfileCOMMON( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.effects[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseEffectProfileCOMMON( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tsurfaces: {},\n\t\t\t\tsamplers: {}\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'newparam':\n\t\t\t\t\t\tparseEffectNewparam( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'technique':\n\t\t\t\t\t\tdata.technique = parseEffectTechnique( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\tdata.extra = parseEffectExtra( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectNewparam( xml, data ) {\n\n\t\t\tconst sid = xml.getAttribute( 'sid' );\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'surface':\n\t\t\t\t\t\tdata.surfaces[ sid ] = parseEffectSurface( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'sampler2D':\n\t\t\t\t\t\tdata.samplers[ sid ] = parseEffectSampler( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseEffectSurface( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'init_from':\n\t\t\t\t\t\tdata.init_from = child.textContent;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectSampler( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tdata.source = child.textContent;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectTechnique( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'constant':\n\t\t\t\t\tcase 'lambert':\n\t\t\t\t\tcase 'blinn':\n\t\t\t\t\tcase 'phong':\n\t\t\t\t\t\tdata.type = child.nodeName;\n\t\t\t\t\t\tdata.parameters = parseEffectParameters( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\tdata.extra = parseEffectExtra( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectParameters( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'emission':\n\t\t\t\t\tcase 'diffuse':\n\t\t\t\t\tcase 'specular':\n\t\t\t\t\tcase 'bump':\n\t\t\t\t\tcase 'ambient':\n\t\t\t\t\tcase 'shininess':\n\t\t\t\t\tcase 'transparency':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseEffectParameter( child );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'transparent':\n\t\t\t\t\t\tdata[ child.nodeName ] = {\n\t\t\t\t\t\t\topaque: child.hasAttribute( 'opaque' ) ? child.getAttribute( 'opaque' ) : 'A_ONE',\n\t\t\t\t\t\t\tdata: parseEffectParameter( child )\n\t\t\t\t\t\t};\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectParameter( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'color':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseFloats( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'float':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseFloat( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'texture':\n\t\t\t\t\t\tdata[ child.nodeName ] = { id: child.getAttribute( 'texture' ), extra: parseEffectParameterTexture( child ) };\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectParameterTexture( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\ttechnique: {}\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\tparseEffectParameterTextureExtra( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectParameterTextureExtra( xml, data ) {\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique':\n\t\t\t\t\t\tparseEffectParameterTextureExtraTechnique( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseEffectParameterTextureExtraTechnique( xml, data ) {\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'repeatU':\n\t\t\t\t\tcase 'repeatV':\n\t\t\t\t\tcase 'offsetU':\n\t\t\t\t\tcase 'offsetV':\n\t\t\t\t\t\tdata.technique[ child.nodeName ] = parseFloat( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'wrapU':\n\t\t\t\t\tcase 'wrapV':\n\n\t\t\t\t\t\t// some files have values for wrapU/wrapV which become NaN via parseInt\n\n\t\t\t\t\t\tif ( child.textContent.toUpperCase() === 'TRUE' ) {\n\n\t\t\t\t\t\t\tdata.technique[ child.nodeName ] = 1;\n\n\t\t\t\t\t\t} else if ( child.textContent.toUpperCase() === 'FALSE' ) {\n\n\t\t\t\t\t\t\tdata.technique[ child.nodeName ] = 0;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tdata.technique[ child.nodeName ] = parseInt( child.textContent );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'bump':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseEffectExtraTechniqueBump( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseEffectExtra( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique':\n\t\t\t\t\t\tdata.technique = parseEffectExtraTechnique( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectExtraTechnique( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'double_sided':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseInt( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'bump':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseEffectExtraTechniqueBump( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseEffectExtraTechniqueBump( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'texture':\n\t\t\t\t\t\tdata[ child.nodeName ] = { id: child.getAttribute( 'texture' ), texcoord: child.getAttribute( 'texcoord' ), extra: parseEffectParameterTexture( child ) };\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildEffect( data ) {\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction getEffect( id ) {\n\n\t\t\treturn getBuild( library.effects[ id ], buildEffect );\n\n\t\t}\n\n\t\t// material\n\n\t\tfunction parseMaterial( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'name' )\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'instance_effect':\n\t\t\t\t\t\tdata.url = parseId( child.getAttribute( 'url' ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.materials[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction getTextureLoader( image ) {\n\n\t\t\tlet loader;\n\n\t\t\tlet extension = image.slice( ( image.lastIndexOf( '.' ) - 1 >>> 0 ) + 2 ); // http://www.jstips.co/en/javascript/get-file-extension/\n\t\t\textension = extension.toLowerCase();\n\n\t\t\tswitch ( extension ) {\n\n\t\t\t\tcase 'tga':\n\t\t\t\t\tloader = tgaLoader;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tloader = textureLoader;\n\n\t\t\t}\n\n\t\t\treturn loader;\n\n\t\t}\n\n\t\tfunction buildMaterial( data ) {\n\n\t\t\tconst effect = getEffect( data.url );\n\t\t\tconst technique = effect.profile.technique;\n\n\t\t\tlet material;\n\n\t\t\tswitch ( technique.type ) {\n\n\t\t\t\tcase 'phong':\n\t\t\t\tcase 'blinn':\n\t\t\t\t\tmaterial = new MeshPhongMaterial();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'lambert':\n\t\t\t\t\tmaterial = new MeshLambertMaterial();\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tmaterial = new MeshBasicMaterial();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tmaterial.name = data.name || '';\n\n\t\t\tfunction getTexture( textureObject, encoding = null ) {\n\n\t\t\t\tconst sampler = effect.profile.samplers[ textureObject.id ];\n\t\t\t\tlet image = null;\n\n\t\t\t\t// get image\n\n\t\t\t\tif ( sampler !== undefined ) {\n\n\t\t\t\t\tconst surface = effect.profile.surfaces[ sampler.source ];\n\t\t\t\t\timage = getImage( surface.init_from );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Undefined sampler. Access image directly (see #12530).' );\n\t\t\t\t\timage = getImage( textureObject.id );\n\n\t\t\t\t}\n\n\t\t\t\t// create texture if image is avaiable\n\n\t\t\t\tif ( image !== null ) {\n\n\t\t\t\t\tconst loader = getTextureLoader( image );\n\n\t\t\t\t\tif ( loader !== undefined ) {\n\n\t\t\t\t\t\tconst texture = loader.load( image );\n\n\t\t\t\t\t\tconst extra = textureObject.extra;\n\n\t\t\t\t\t\tif ( extra !== undefined && extra.technique !== undefined && isEmpty( extra.technique ) === false ) {\n\n\t\t\t\t\t\t\tconst technique = extra.technique;\n\n\t\t\t\t\t\t\ttexture.wrapS = technique.wrapU ? RepeatWrapping : ClampToEdgeWrapping;\n\t\t\t\t\t\t\ttexture.wrapT = technique.wrapV ? RepeatWrapping : ClampToEdgeWrapping;\n\n\t\t\t\t\t\t\ttexture.offset.set( technique.offsetU || 0, technique.offsetV || 0 );\n\t\t\t\t\t\t\ttexture.repeat.set( technique.repeatU || 1, technique.repeatV || 1 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttexture.wrapS = RepeatWrapping;\n\t\t\t\t\t\t\ttexture.wrapT = RepeatWrapping;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( encoding !== null ) {\n\n\t\t\t\t\t\t\ttexture.encoding = encoding;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn texture;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Loader for texture %s not found.', image );\n\n\t\t\t\t\t\treturn null;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t create texture with ID:', textureObject.id );\n\n\t\t\t\t\treturn null;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst parameters = technique.parameters;\n\n\t\t\tfor ( const key in parameters ) {\n\n\t\t\t\tconst parameter = parameters[ key ];\n\n\t\t\t\tswitch ( key ) {\n\n\t\t\t\t\tcase 'diffuse':\n\t\t\t\t\t\tif ( parameter.color ) material.color.fromArray( parameter.color );\n\t\t\t\t\t\tif ( parameter.texture ) material.map = getTexture( parameter.texture, sRGBEncoding );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'specular':\n\t\t\t\t\t\tif ( parameter.color && material.specular ) material.specular.fromArray( parameter.color );\n\t\t\t\t\t\tif ( parameter.texture ) material.specularMap = getTexture( parameter.texture );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'bump':\n\t\t\t\t\t\tif ( parameter.texture ) material.normalMap = getTexture( parameter.texture );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'ambient':\n\t\t\t\t\t\tif ( parameter.texture ) material.lightMap = getTexture( parameter.texture, sRGBEncoding );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'shininess':\n\t\t\t\t\t\tif ( parameter.float && material.shininess ) material.shininess = parameter.float;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'emission':\n\t\t\t\t\t\tif ( parameter.color && material.emissive ) material.emissive.fromArray( parameter.color );\n\t\t\t\t\t\tif ( parameter.texture ) material.emissiveMap = getTexture( parameter.texture, sRGBEncoding );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tmaterial.color.convertSRGBToLinear();\n\t\t\tif ( material.specular ) material.specular.convertSRGBToLinear();\n\t\t\tif ( material.emissive ) material.emissive.convertSRGBToLinear();\n\n\t\t\t//\n\n\t\t\tlet transparent = parameters[ 'transparent' ];\n\t\t\tlet transparency = parameters[ 'transparency' ];\n\n\t\t\t// <transparency> does not exist but <transparent>\n\n\t\t\tif ( transparency === undefined && transparent ) {\n\n\t\t\t\ttransparency = {\n\t\t\t\t\tfloat: 1\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\t// <transparent> does not exist but <transparency>\n\n\t\t\tif ( transparent === undefined && transparency ) {\n\n\t\t\t\ttransparent = {\n\t\t\t\t\topaque: 'A_ONE',\n\t\t\t\t\tdata: {\n\t\t\t\t\t\tcolor: [ 1, 1, 1, 1 ]\n\t\t\t\t\t} };\n\n\t\t\t}\n\n\t\t\tif ( transparent && transparency ) {\n\n\t\t\t\t// handle case if a texture exists but no color\n\n\t\t\t\tif ( transparent.data.texture ) {\n\n\t\t\t\t\t// we do not set an alpha map (see #13792)\n\n\t\t\t\t\tmaterial.transparent = true;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconst color = transparent.data.color;\n\n\t\t\t\t\tswitch ( transparent.opaque ) {\n\n\t\t\t\t\t\tcase 'A_ONE':\n\t\t\t\t\t\t\tmaterial.opacity = color[ 3 ] * transparency.float;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'RGB_ZERO':\n\t\t\t\t\t\t\tmaterial.opacity = 1 - ( color[ 0 ] * transparency.float );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'A_ZERO':\n\t\t\t\t\t\t\tmaterial.opacity = 1 - ( color[ 3 ] * transparency.float );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'RGB_ONE':\n\t\t\t\t\t\t\tmaterial.opacity = color[ 0 ] * transparency.float;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Invalid opaque type \"%s\" of transparent tag.', transparent.opaque );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( material.opacity < 1 ) material.transparent = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\n\n\t\t\tif ( technique.extra !== undefined && technique.extra.technique !== undefined ) {\n\n\t\t\t\tconst techniques = technique.extra.technique;\n\n\t\t\t\tfor ( const k in techniques ) {\n\n\t\t\t\t\tconst v = techniques[ k ];\n\n\t\t\t\t\tswitch ( k ) {\n\n\t\t\t\t\t\tcase 'double_sided':\n\t\t\t\t\t\t\tmaterial.side = ( v === 1 ? DoubleSide : FrontSide );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'bump':\n\t\t\t\t\t\t\tmaterial.normalMap = getTexture( v.texture );\n\t\t\t\t\t\t\tmaterial.normalScale = new Vector2( 1, 1 );\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn material;\n\n\t\t}\n\n\t\tfunction getMaterial( id ) {\n\n\t\t\treturn getBuild( library.materials[ id ], buildMaterial );\n\n\t\t}\n\n\t\t// camera\n\n\t\tfunction parseCamera( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'name' )\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'optics':\n\t\t\t\t\t\tdata.optics = parseCameraOptics( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.cameras[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseCameraOptics( xml ) {\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\treturn parseCameraTechnique( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn {};\n\n\t\t}\n\n\t\tfunction parseCameraTechnique( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'perspective':\n\t\t\t\t\tcase 'orthographic':\n\n\t\t\t\t\t\tdata.technique = child.nodeName;\n\t\t\t\t\t\tdata.parameters = parseCameraParameters( child );\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseCameraParameters( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'xfov':\n\t\t\t\t\tcase 'yfov':\n\t\t\t\t\tcase 'xmag':\n\t\t\t\t\tcase 'ymag':\n\t\t\t\t\tcase 'znear':\n\t\t\t\t\tcase 'zfar':\n\t\t\t\t\tcase 'aspect_ratio':\n\t\t\t\t\t\tdata[ child.nodeName ] = parseFloat( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildCamera( data ) {\n\n\t\t\tlet camera;\n\n\t\t\tswitch ( data.optics.technique ) {\n\n\t\t\t\tcase 'perspective':\n\t\t\t\t\tcamera = new PerspectiveCamera(\n\t\t\t\t\t\tdata.optics.parameters.yfov,\n\t\t\t\t\t\tdata.optics.parameters.aspect_ratio,\n\t\t\t\t\t\tdata.optics.parameters.znear,\n\t\t\t\t\t\tdata.optics.parameters.zfar\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'orthographic':\n\t\t\t\t\tlet ymag = data.optics.parameters.ymag;\n\t\t\t\t\tlet xmag = data.optics.parameters.xmag;\n\t\t\t\t\tconst aspectRatio = data.optics.parameters.aspect_ratio;\n\n\t\t\t\t\txmag = ( xmag === undefined ) ? ( ymag * aspectRatio ) : xmag;\n\t\t\t\t\tymag = ( ymag === undefined ) ? ( xmag / aspectRatio ) : ymag;\n\n\t\t\t\t\txmag *= 0.5;\n\t\t\t\t\tymag *= 0.5;\n\n\t\t\t\t\tcamera = new OrthographicCamera(\n\t\t\t\t\t\t- xmag, xmag, ymag, - ymag, // left, right, top, bottom\n\t\t\t\t\t\tdata.optics.parameters.znear,\n\t\t\t\t\t\tdata.optics.parameters.zfar\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tcamera = new PerspectiveCamera();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tcamera.name = data.name || '';\n\n\t\t\treturn camera;\n\n\t\t}\n\n\t\tfunction getCamera( id ) {\n\n\t\t\tconst data = library.cameras[ id ];\n\n\t\t\tif ( data !== undefined ) {\n\n\t\t\t\treturn getBuild( data, buildCamera );\n\n\t\t\t}\n\n\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t find camera with ID:', id );\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// light\n\n\t\tfunction parseLight( xml ) {\n\n\t\t\tlet data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tdata = parseLightTechnique( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.lights[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseLightTechnique( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'directional':\n\t\t\t\t\tcase 'point':\n\t\t\t\t\tcase 'spot':\n\t\t\t\t\tcase 'ambient':\n\n\t\t\t\t\t\tdata.technique = child.nodeName;\n\t\t\t\t\t\tdata.parameters = parseLightParameters( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseLightParameters( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'color':\n\t\t\t\t\t\tconst array = parseFloats( child.textContent );\n\t\t\t\t\t\tdata.color = new Color().fromArray( array ).convertSRGBToLinear();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'falloff_angle':\n\t\t\t\t\t\tdata.falloffAngle = parseFloat( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'quadratic_attenuation':\n\t\t\t\t\t\tconst f = parseFloat( child.textContent );\n\t\t\t\t\t\tdata.distance = f ? Math.sqrt( 1 / f ) : 0;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildLight( data ) {\n\n\t\t\tlet light;\n\n\t\t\tswitch ( data.technique ) {\n\n\t\t\t\tcase 'directional':\n\t\t\t\t\tlight = new DirectionalLight();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'point':\n\t\t\t\t\tlight = new PointLight();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'spot':\n\t\t\t\t\tlight = new SpotLight();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ambient':\n\t\t\t\t\tlight = new AmbientLight();\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( data.parameters.color ) light.color.copy( data.parameters.color );\n\t\t\tif ( data.parameters.distance ) light.distance = data.parameters.distance;\n\n\t\t\treturn light;\n\n\t\t}\n\n\t\tfunction getLight( id ) {\n\n\t\t\tconst data = library.lights[ id ];\n\n\t\t\tif ( data !== undefined ) {\n\n\t\t\t\treturn getBuild( data, buildLight );\n\n\t\t\t}\n\n\t\t\tconsole.warn( 'THREE.ColladaLoader: Couldn\\'t find light with ID:', id );\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// geometry\n\n\t\tfunction parseGeometry( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'name' ),\n\t\t\t\tsources: {},\n\t\t\t\tvertices: {},\n\t\t\t\tprimitives: []\n\t\t\t};\n\n\t\t\tconst mesh = getElementsByTagName( xml, 'mesh' )[ 0 ];\n\n\t\t\t// the following tags inside geometry are not supported yet (see https://github.com/mrdoob/three.js/pull/12606): convex_mesh, spline, brep\n\t\t\tif ( mesh === undefined ) return;\n\n\t\t\tfor ( let i = 0; i < mesh.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = mesh.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tconst id = child.getAttribute( 'id' );\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'source':\n\t\t\t\t\t\tdata.sources[ id ] = parseSource( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'vertices':\n\t\t\t\t\t\t// data.sources[ id ] = data.sources[ parseId( getElementsByTagName( child, 'input' )[ 0 ].getAttribute( 'source' ) ) ];\n\t\t\t\t\t\tdata.vertices = parseGeometryVertices( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'polygons':\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Unsupported primitive type: ', child.nodeName );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'lines':\n\t\t\t\t\tcase 'linestrips':\n\t\t\t\t\tcase 'polylist':\n\t\t\t\t\tcase 'triangles':\n\t\t\t\t\t\tdata.primitives.push( parseGeometryPrimitive( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.log( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.geometries[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parseSource( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tarray: [],\n\t\t\t\tstride: 3\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'float_array':\n\t\t\t\t\t\tdata.array = parseFloats( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Name_array':\n\t\t\t\t\t\tdata.array = parseStrings( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tconst accessor = getElementsByTagName( child, 'accessor' )[ 0 ];\n\n\t\t\t\t\t\tif ( accessor !== undefined ) {\n\n\t\t\t\t\t\t\tdata.stride = parseInt( accessor.getAttribute( 'stride' ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseGeometryVertices( xml ) {\n\n\t\t\tconst data = {};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tdata[ child.getAttribute( 'semantic' ) ] = parseId( child.getAttribute( 'source' ) );\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseGeometryPrimitive( xml ) {\n\n\t\t\tconst primitive = {\n\t\t\t\ttype: xml.nodeName,\n\t\t\t\tmaterial: xml.getAttribute( 'material' ),\n\t\t\t\tcount: parseInt( xml.getAttribute( 'count' ) ),\n\t\t\t\tinputs: {},\n\t\t\t\tstride: 0,\n\t\t\t\thasUV: false\n\t\t\t};\n\n\t\t\tfor ( let i = 0, l = xml.childNodes.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'input':\n\t\t\t\t\t\tconst id = parseId( child.getAttribute( 'source' ) );\n\t\t\t\t\t\tconst semantic = child.getAttribute( 'semantic' );\n\t\t\t\t\t\tconst offset = parseInt( child.getAttribute( 'offset' ) );\n\t\t\t\t\t\tconst set = parseInt( child.getAttribute( 'set' ) );\n\t\t\t\t\t\tconst inputname = ( set > 0 ? semantic + set : semantic );\n\t\t\t\t\t\tprimitive.inputs[ inputname ] = { id: id, offset: offset };\n\t\t\t\t\t\tprimitive.stride = Math.max( primitive.stride, offset + 1 );\n\t\t\t\t\t\tif ( semantic === 'TEXCOORD' ) primitive.hasUV = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'vcount':\n\t\t\t\t\t\tprimitive.vcount = parseInts( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'p':\n\t\t\t\t\t\tprimitive.p = parseInts( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn primitive;\n\n\t\t}\n\n\t\tfunction groupPrimitives( primitives ) {\n\n\t\t\tconst build = {};\n\n\t\t\tfor ( let i = 0; i < primitives.length; i ++ ) {\n\n\t\t\t\tconst primitive = primitives[ i ];\n\n\t\t\t\tif ( build[ primitive.type ] === undefined ) build[ primitive.type ] = [];\n\n\t\t\t\tbuild[ primitive.type ].push( primitive );\n\n\t\t\t}\n\n\t\t\treturn build;\n\n\t\t}\n\n\t\tfunction checkUVCoordinates( primitives ) {\n\n\t\t\tlet count = 0;\n\n\t\t\tfor ( let i = 0, l = primitives.length; i < l; i ++ ) {\n\n\t\t\t\tconst primitive = primitives[ i ];\n\n\t\t\t\tif ( primitive.hasUV === true ) {\n\n\t\t\t\t\tcount ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( count > 0 && count < primitives.length ) {\n\n\t\t\t\tprimitives.uvsNeedsFix = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction buildGeometry( data ) {\n\n\t\t\tconst build = {};\n\n\t\t\tconst sources = data.sources;\n\t\t\tconst vertices = data.vertices;\n\t\t\tconst primitives = data.primitives;\n\n\t\t\tif ( primitives.length === 0 ) return {};\n\n\t\t\t// our goal is to create one buffer geometry for a single type of primitives\n\t\t\t// first, we group all primitives by their type\n\n\t\t\tconst groupedPrimitives = groupPrimitives( primitives );\n\n\t\t\tfor ( const type in groupedPrimitives ) {\n\n\t\t\t\tconst primitiveType = groupedPrimitives[ type ];\n\n\t\t\t\t// second, ensure consistent uv coordinates for each type of primitives (polylist,triangles or lines)\n\n\t\t\t\tcheckUVCoordinates( primitiveType );\n\n\t\t\t\t// third, create a buffer geometry for each type of primitives\n\n\t\t\t\tbuild[ type ] = buildGeometryType( primitiveType, sources, vertices );\n\n\t\t\t}\n\n\t\t\treturn build;\n\n\t\t}\n\n\t\tfunction buildGeometryType( primitives, sources, vertices ) {\n\n\t\t\tconst build = {};\n\n\t\t\tconst position = { array: [], stride: 0 };\n\t\t\tconst normal = { array: [], stride: 0 };\n\t\t\tconst uv = { array: [], stride: 0 };\n\t\t\tconst uv2 = { array: [], stride: 0 };\n\t\t\tconst color = { array: [], stride: 0 };\n\n\t\t\tconst skinIndex = { array: [], stride: 4 };\n\t\t\tconst skinWeight = { array: [], stride: 4 };\n\n\t\t\tconst geometry = new BufferGeometry();\n\n\t\t\tconst materialKeys = [];\n\n\t\t\tlet start = 0;\n\n\t\t\tfor ( let p = 0; p < primitives.length; p ++ ) {\n\n\t\t\t\tconst primitive = primitives[ p ];\n\t\t\t\tconst inputs = primitive.inputs;\n\n\t\t\t\t// groups\n\n\t\t\t\tlet count = 0;\n\n\t\t\t\tswitch ( primitive.type ) {\n\n\t\t\t\t\tcase 'lines':\n\t\t\t\t\tcase 'linestrips':\n\t\t\t\t\t\tcount = primitive.count * 2;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'triangles':\n\t\t\t\t\t\tcount = primitive.count * 3;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'polylist':\n\n\t\t\t\t\t\tfor ( let g = 0; g < primitive.count; g ++ ) {\n\n\t\t\t\t\t\t\tconst vc = primitive.vcount[ g ];\n\n\t\t\t\t\t\t\tswitch ( vc ) {\n\n\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\tcount += 3; // single triangle\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\t\tcount += 6; // quad, subdivided into two triangles\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tcount += ( vc - 2 ) * 3; // polylist with more than four vertices\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Unknow primitive type:', primitive.type );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.addGroup( start, count, p );\n\t\t\t\tstart += count;\n\n\t\t\t\t// material\n\n\t\t\t\tif ( primitive.material ) {\n\n\t\t\t\t\tmaterialKeys.push( primitive.material );\n\n\t\t\t\t}\n\n\t\t\t\t// geometry data\n\n\t\t\t\tfor ( const name in inputs ) {\n\n\t\t\t\t\tconst input = inputs[ name ];\n\n\t\t\t\t\tswitch ( name )\t{\n\n\t\t\t\t\t\tcase 'VERTEX':\n\t\t\t\t\t\t\tfor ( const key in vertices ) {\n\n\t\t\t\t\t\t\t\tconst id = vertices[ key ];\n\n\t\t\t\t\t\t\t\tswitch ( key ) {\n\n\t\t\t\t\t\t\t\t\tcase 'POSITION':\n\t\t\t\t\t\t\t\t\t\tconst prevLength = position.array.length;\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, position.array );\n\t\t\t\t\t\t\t\t\t\tposition.stride = sources[ id ].stride;\n\n\t\t\t\t\t\t\t\t\t\tif ( sources.skinWeights && sources.skinIndices ) {\n\n\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources.skinIndices, input.offset, skinIndex.array );\n\t\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources.skinWeights, input.offset, skinWeight.array );\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// see #3803\n\n\t\t\t\t\t\t\t\t\t\tif ( primitive.hasUV === false && primitives.uvsNeedsFix === true ) {\n\n\t\t\t\t\t\t\t\t\t\t\tconst count = ( position.array.length - prevLength ) / position.stride;\n\n\t\t\t\t\t\t\t\t\t\t\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// fill missing uv coordinates\n\n\t\t\t\t\t\t\t\t\t\t\t\tuv.array.push( 0, 0 );\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'NORMAL':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, normal.array );\n\t\t\t\t\t\t\t\t\t\tnormal.stride = sources[ id ].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'COLOR':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, color.array );\n\t\t\t\t\t\t\t\t\t\tcolor.stride = sources[ id ].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'TEXCOORD':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, uv.array );\n\t\t\t\t\t\t\t\t\t\tuv.stride = sources[ id ].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tcase 'TEXCOORD1':\n\t\t\t\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ id ], input.offset, uv2.array );\n\t\t\t\t\t\t\t\t\t\tuv.stride = sources[ id ].stride;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Semantic \"%s\" not handled in geometry build process.', key );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'NORMAL':\n\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, normal.array );\n\t\t\t\t\t\t\tnormal.stride = sources[ input.id ].stride;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'COLOR':\n\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, color.array, true );\n\t\t\t\t\t\t\tcolor.stride = sources[ input.id ].stride;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'TEXCOORD':\n\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, uv.array );\n\t\t\t\t\t\t\tuv.stride = sources[ input.id ].stride;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'TEXCOORD1':\n\t\t\t\t\t\t\tbuildGeometryData( primitive, sources[ input.id ], input.offset, uv2.array );\n\t\t\t\t\t\t\tuv2.stride = sources[ input.id ].stride;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// build geometry\n\n\t\t\tif ( position.array.length > 0 ) geometry.setAttribute( 'position', new Float32BufferAttribute( position.array, position.stride ) );\n\t\t\tif ( normal.array.length > 0 ) geometry.setAttribute( 'normal', new Float32BufferAttribute( normal.array, normal.stride ) );\n\t\t\tif ( color.array.length > 0 ) geometry.setAttribute( 'color', new Float32BufferAttribute( color.array, color.stride ) );\n\t\t\tif ( uv.array.length > 0 ) geometry.setAttribute( 'uv', new Float32BufferAttribute( uv.array, uv.stride ) );\n\t\t\tif ( uv2.array.length > 0 ) geometry.setAttribute( 'uv2', new Float32BufferAttribute( uv2.array, uv2.stride ) );\n\n\t\t\tif ( skinIndex.array.length > 0 ) geometry.setAttribute( 'skinIndex', new Float32BufferAttribute( skinIndex.array, skinIndex.stride ) );\n\t\t\tif ( skinWeight.array.length > 0 ) geometry.setAttribute( 'skinWeight', new Float32BufferAttribute( skinWeight.array, skinWeight.stride ) );\n\n\t\t\tbuild.data = geometry;\n\t\t\tbuild.type = primitives[ 0 ].type;\n\t\t\tbuild.materialKeys = materialKeys;\n\n\t\t\treturn build;\n\n\t\t}\n\n\t\tfunction buildGeometryData( primitive, source, offset, array, isColor = false ) {\n\n\t\t\tconst indices = primitive.p;\n\t\t\tconst stride = primitive.stride;\n\t\t\tconst vcount = primitive.vcount;\n\n\t\t\tfunction pushVector( i ) {\n\n\t\t\t\tlet index = indices[ i + offset ] * sourceStride;\n\t\t\t\tconst length = index + sourceStride;\n\n\t\t\t\tfor ( ; index < length; index ++ ) {\n\n\t\t\t\t\tarray.push( sourceArray[ index ] );\n\n\t\t\t\t}\n\n\t\t\t\tif ( isColor ) {\n\n\t\t\t\t\t// convert the vertex colors from srgb to linear if present\n\t\t\t\t\tconst startIndex = array.length - sourceStride - 1;\n\t\t\t\t\ttempColor.setRGB(\n\t\t\t\t\t\tarray[ startIndex + 0 ],\n\t\t\t\t\t\tarray[ startIndex + 1 ],\n\t\t\t\t\t\tarray[ startIndex + 2 ]\n\t\t\t\t\t).convertSRGBToLinear();\n\n\t\t\t\t\tarray[ startIndex + 0 ] = tempColor.r;\n\t\t\t\t\tarray[ startIndex + 1 ] = tempColor.g;\n\t\t\t\t\tarray[ startIndex + 2 ] = tempColor.b;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst sourceArray = source.array;\n\t\t\tconst sourceStride = source.stride;\n\n\t\t\tif ( primitive.vcount !== undefined ) {\n\n\t\t\t\tlet index = 0;\n\n\t\t\t\tfor ( let i = 0, l = vcount.length; i < l; i ++ ) {\n\n\t\t\t\t\tconst count = vcount[ i ];\n\n\t\t\t\t\tif ( count === 4 ) {\n\n\t\t\t\t\t\tconst a = index + stride * 0;\n\t\t\t\t\t\tconst b = index + stride * 1;\n\t\t\t\t\t\tconst c = index + stride * 2;\n\t\t\t\t\t\tconst d = index + stride * 3;\n\n\t\t\t\t\t\tpushVector( a ); pushVector( b ); pushVector( d );\n\t\t\t\t\t\tpushVector( b ); pushVector( c ); pushVector( d );\n\n\t\t\t\t\t} else if ( count === 3 ) {\n\n\t\t\t\t\t\tconst a = index + stride * 0;\n\t\t\t\t\t\tconst b = index + stride * 1;\n\t\t\t\t\t\tconst c = index + stride * 2;\n\n\t\t\t\t\t\tpushVector( a ); pushVector( b ); pushVector( c );\n\n\t\t\t\t\t} else if ( count > 4 ) {\n\n\t\t\t\t\t\tfor ( let k = 1, kl = ( count - 2 ); k <= kl; k ++ ) {\n\n\t\t\t\t\t\t\tconst a = index + stride * 0;\n\t\t\t\t\t\t\tconst b = index + stride * k;\n\t\t\t\t\t\t\tconst c = index + stride * ( k + 1 );\n\n\t\t\t\t\t\t\tpushVector( a ); pushVector( b ); pushVector( c );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tindex += stride * count;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( let i = 0, l = indices.length; i < l; i += stride ) {\n\n\t\t\t\t\tpushVector( i );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction getGeometry( id ) {\n\n\t\t\treturn getBuild( library.geometries[ id ], buildGeometry );\n\n\t\t}\n\n\t\t// kinematics\n\n\t\tfunction parseKinematicsModel( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\tjoints: {},\n\t\t\t\tlinks: []\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tparseKinematicsTechniqueCommon( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.kinematicsModels[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction buildKinematicsModel( data ) {\n\n\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction getKinematicsModel( id ) {\n\n\t\t\treturn getBuild( library.kinematicsModels[ id ], buildKinematicsModel );\n\n\t\t}\n\n\t\tfunction parseKinematicsTechniqueCommon( xml, data ) {\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'joint':\n\t\t\t\t\t\tdata.joints[ child.getAttribute( 'sid' ) ] = parseKinematicsJoint( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'link':\n\t\t\t\t\t\tdata.links.push( parseKinematicsLink( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parseKinematicsJoint( xml ) {\n\n\t\t\tlet data;\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'prismatic':\n\t\t\t\t\tcase 'revolute':\n\t\t\t\t\t\tdata = parseKinematicsJointParameter( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseKinematicsJointParameter( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tsid: xml.getAttribute( 'sid' ),\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\taxis: new Vector3(),\n\t\t\t\tlimits: {\n\t\t\t\t\tmin: 0,\n\t\t\t\t\tmax: 0\n\t\t\t\t},\n\t\t\t\ttype: xml.nodeName,\n\t\t\t\tstatic: false,\n\t\t\t\tzeroPosition: 0,\n\t\t\t\tmiddlePosition: 0\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'axis':\n\t\t\t\t\t\tconst array = parseFloats( child.textContent );\n\t\t\t\t\t\tdata.axis.fromArray( array );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'limits':\n\t\t\t\t\t\tconst max = child.getElementsByTagName( 'max' )[ 0 ];\n\t\t\t\t\t\tconst min = child.getElementsByTagName( 'min' )[ 0 ];\n\n\t\t\t\t\t\tdata.limits.max = parseFloat( max.textContent );\n\t\t\t\t\t\tdata.limits.min = parseFloat( min.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// if min is equal to or greater than max, consider the joint static\n\n\t\t\tif ( data.limits.min >= data.limits.max ) {\n\n\t\t\t\tdata.static = true;\n\n\t\t\t}\n\n\t\t\t// calculate middle position\n\n\t\t\tdata.middlePosition = ( data.limits.min + data.limits.max ) / 2.0;\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseKinematicsLink( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tsid: xml.getAttribute( 'sid' ),\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\tattachments: [],\n\t\t\t\ttransforms: []\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'attachment_full':\n\t\t\t\t\t\tdata.attachments.push( parseKinematicsAttachment( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tdata.transforms.push( parseKinematicsTransform( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseKinematicsAttachment( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tjoint: xml.getAttribute( 'joint' ).split( '/' ).pop(),\n\t\t\t\ttransforms: [],\n\t\t\t\tlinks: []\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'link':\n\t\t\t\t\t\tdata.links.push( parseKinematicsLink( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tdata.transforms.push( parseKinematicsTransform( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseKinematicsTransform( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\ttype: xml.nodeName\n\t\t\t};\n\n\t\t\tconst array = parseFloats( xml.textContent );\n\n\t\t\tswitch ( data.type ) {\n\n\t\t\t\tcase 'matrix':\n\t\t\t\t\tdata.obj = new Matrix4();\n\t\t\t\t\tdata.obj.fromArray( array ).transpose();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'translate':\n\t\t\t\t\tdata.obj = new Vector3();\n\t\t\t\t\tdata.obj.fromArray( array );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rotate':\n\t\t\t\t\tdata.obj = new Vector3();\n\t\t\t\t\tdata.obj.fromArray( array );\n\t\t\t\t\tdata.angle = MathUtils.degToRad( array[ 3 ] );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\t// physics\n\n\t\tfunction parsePhysicsModel( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\trigidBodies: {}\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'rigid_body':\n\t\t\t\t\t\tdata.rigidBodies[ child.getAttribute( 'name' ) ] = {};\n\t\t\t\t\t\tparsePhysicsRigidBody( child, data.rigidBodies[ child.getAttribute( 'name' ) ] );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.physicsModels[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction parsePhysicsRigidBody( xml, data ) {\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'technique_common':\n\t\t\t\t\t\tparsePhysicsTechniqueCommon( child, data );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parsePhysicsTechniqueCommon( xml, data ) {\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'inertia':\n\t\t\t\t\t\tdata.inertia = parseFloats( child.textContent );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'mass':\n\t\t\t\t\t\tdata.mass = parseFloats( child.textContent )[ 0 ];\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// scene\n\n\t\tfunction parseKinematicsScene( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tbindJointAxis: []\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'bind_joint_axis':\n\t\t\t\t\t\tdata.bindJointAxis.push( parseKinematicsBindJointAxis( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlibrary.kinematicsScenes[ parseId( xml.getAttribute( 'url' ) ) ] = data;\n\n\t\t}\n\n\t\tfunction parseKinematicsBindJointAxis( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\ttarget: xml.getAttribute( 'target' ).split( '/' ).pop()\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'axis':\n\t\t\t\t\t\tconst param = child.getElementsByTagName( 'param' )[ 0 ];\n\t\t\t\t\t\tdata.axis = param.textContent;\n\t\t\t\t\t\tconst tmpJointIndex = data.axis.split( 'inst_' ).pop().split( 'axis' )[ 0 ];\n\t\t\t\t\t\tdata.jointIndex = tmpJointIndex.substring( 0, tmpJointIndex.length - 1 );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildKinematicsScene( data ) {\n\n\t\t\tif ( data.build !== undefined ) return data.build;\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction getKinematicsScene( id ) {\n\n\t\t\treturn getBuild( library.kinematicsScenes[ id ], buildKinematicsScene );\n\n\t\t}\n\n\t\tfunction setupKinematics() {\n\n\t\t\tconst kinematicsModelId = Object.keys( library.kinematicsModels )[ 0 ];\n\t\t\tconst kinematicsSceneId = Object.keys( library.kinematicsScenes )[ 0 ];\n\t\t\tconst visualSceneId = Object.keys( library.visualScenes )[ 0 ];\n\n\t\t\tif ( kinematicsModelId === undefined || kinematicsSceneId === undefined ) return;\n\n\t\t\tconst kinematicsModel = getKinematicsModel( kinematicsModelId );\n\t\t\tconst kinematicsScene = getKinematicsScene( kinematicsSceneId );\n\t\t\tconst visualScene = getVisualScene( visualSceneId );\n\n\t\t\tconst bindJointAxis = kinematicsScene.bindJointAxis;\n\t\t\tconst jointMap = {};\n\n\t\t\tfor ( let i = 0, l = bindJointAxis.length; i < l; i ++ ) {\n\n\t\t\t\tconst axis = bindJointAxis[ i ];\n\n\t\t\t\t// the result of the following query is an element of type 'translate', 'rotate','scale' or 'matrix'\n\n\t\t\t\tconst targetElement = collada.querySelector( '[sid=\"' + axis.target + '\"]' );\n\n\t\t\t\tif ( targetElement ) {\n\n\t\t\t\t\t// get the parent of the transform element\n\n\t\t\t\t\tconst parentVisualElement = targetElement.parentElement;\n\n\t\t\t\t\t// connect the joint of the kinematics model with the element in the visual scene\n\n\t\t\t\t\tconnect( axis.jointIndex, parentVisualElement );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction connect( jointIndex, visualElement ) {\n\n\t\t\t\tconst visualElementName = visualElement.getAttribute( 'name' );\n\t\t\t\tconst joint = kinematicsModel.joints[ jointIndex ];\n\n\t\t\t\tvisualScene.traverse( function ( object ) {\n\n\t\t\t\t\tif ( object.name === visualElementName ) {\n\n\t\t\t\t\t\tjointMap[ jointIndex ] = {\n\t\t\t\t\t\t\tobject: object,\n\t\t\t\t\t\t\ttransforms: buildTransformList( visualElement ),\n\t\t\t\t\t\t\tjoint: joint,\n\t\t\t\t\t\t\tposition: joint.zeroPosition\n\t\t\t\t\t\t};\n\n\t\t\t\t\t}\n\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\tconst m0 = new Matrix4();\n\n\t\t\tkinematics = {\n\n\t\t\t\tjoints: kinematicsModel && kinematicsModel.joints,\n\n\t\t\t\tgetJointValue: function ( jointIndex ) {\n\n\t\t\t\t\tconst jointData = jointMap[ jointIndex ];\n\n\t\t\t\t\tif ( jointData ) {\n\n\t\t\t\t\t\treturn jointData.position;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' doesn\\'t exist.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t},\n\n\t\t\t\tsetJointValue: function ( jointIndex, value ) {\n\n\t\t\t\t\tconst jointData = jointMap[ jointIndex ];\n\n\t\t\t\t\tif ( jointData ) {\n\n\t\t\t\t\t\tconst joint = jointData.joint;\n\n\t\t\t\t\t\tif ( value > joint.limits.max || value < joint.limits.min ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' value ' + value + ' outside of limits (min: ' + joint.limits.min + ', max: ' + joint.limits.max + ').' );\n\n\t\t\t\t\t\t} else if ( joint.static ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Joint ' + jointIndex + ' is static.' );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tconst object = jointData.object;\n\t\t\t\t\t\t\tconst axis = joint.axis;\n\t\t\t\t\t\t\tconst transforms = jointData.transforms;\n\n\t\t\t\t\t\t\tmatrix.identity();\n\n\t\t\t\t\t\t\t// each update, we have to apply all transforms in the correct order\n\n\t\t\t\t\t\t\tfor ( let i = 0; i < transforms.length; i ++ ) {\n\n\t\t\t\t\t\t\t\tconst transform = transforms[ i ];\n\n\t\t\t\t\t\t\t\t// if there is a connection of the transform node with a joint, apply the joint value\n\n\t\t\t\t\t\t\t\tif ( transform.sid && transform.sid.indexOf( jointIndex ) !== - 1 ) {\n\n\t\t\t\t\t\t\t\t\tswitch ( joint.type ) {\n\n\t\t\t\t\t\t\t\t\t\tcase 'revolute':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeRotationAxis( axis, MathUtils.degToRad( value ) ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'prismatic':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeTranslation( axis.x * value, axis.y * value, axis.z * value ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Unknown joint type: ' + joint.type );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tswitch ( transform.type ) {\n\n\t\t\t\t\t\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( transform.obj );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'translate':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeTranslation( transform.obj.x, transform.obj.y, transform.obj.z ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.scale( transform.obj );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\t\t\t\t\t\tmatrix.multiply( m0.makeRotationAxis( transform.obj, transform.angle ) );\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tobject.matrix.copy( matrix );\n\t\t\t\t\t\t\tobject.matrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t\t\t\t\t\tjointMap[ jointIndex ].position = value;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.log( 'THREE.ColladaLoader: ' + jointIndex + ' does not exist.' );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\tfunction buildTransformList( node ) {\n\n\t\t\tconst transforms = [];\n\n\t\t\tconst xml = collada.querySelector( '[id=\"' + node.id + '\"]' );\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tlet array, vector;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\tarray = parseFloats( child.textContent );\n\t\t\t\t\t\tconst matrix = new Matrix4().fromArray( array ).transpose();\n\t\t\t\t\t\ttransforms.push( {\n\t\t\t\t\t\t\tsid: child.getAttribute( 'sid' ),\n\t\t\t\t\t\t\ttype: child.nodeName,\n\t\t\t\t\t\t\tobj: matrix\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\tarray = parseFloats( child.textContent );\n\t\t\t\t\t\tvector = new Vector3().fromArray( array );\n\t\t\t\t\t\ttransforms.push( {\n\t\t\t\t\t\t\tsid: child.getAttribute( 'sid' ),\n\t\t\t\t\t\t\ttype: child.nodeName,\n\t\t\t\t\t\t\tobj: vector\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tarray = parseFloats( child.textContent );\n\t\t\t\t\t\tvector = new Vector3().fromArray( array );\n\t\t\t\t\t\tconst angle = MathUtils.degToRad( array[ 3 ] );\n\t\t\t\t\t\ttransforms.push( {\n\t\t\t\t\t\t\tsid: child.getAttribute( 'sid' ),\n\t\t\t\t\t\t\ttype: child.nodeName,\n\t\t\t\t\t\t\tobj: vector,\n\t\t\t\t\t\t\tangle: angle\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn transforms;\n\n\t\t}\n\n\t\t// nodes\n\n\t\tfunction prepareNodes( xml ) {\n\n\t\t\tconst elements = xml.getElementsByTagName( 'node' );\n\n\t\t\t// ensure all node elements have id attributes\n\n\t\t\tfor ( let i = 0; i < elements.length; i ++ ) {\n\n\t\t\t\tconst element = elements[ i ];\n\n\t\t\t\tif ( element.hasAttribute( 'id' ) === false ) {\n\n\t\t\t\t\telement.setAttribute( 'id', generateId() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst matrix = new Matrix4();\n\t\tconst vector = new Vector3();\n\n\t\tfunction parseNode( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'name' ) || '',\n\t\t\t\ttype: xml.getAttribute( 'type' ),\n\t\t\t\tid: xml.getAttribute( 'id' ),\n\t\t\t\tsid: xml.getAttribute( 'sid' ),\n\t\t\t\tmatrix: new Matrix4(),\n\t\t\t\tnodes: [],\n\t\t\t\tinstanceCameras: [],\n\t\t\t\tinstanceControllers: [],\n\t\t\t\tinstanceLights: [],\n\t\t\t\tinstanceGeometries: [],\n\t\t\t\tinstanceNodes: [],\n\t\t\t\ttransforms: {}\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tif ( child.nodeType !== 1 ) continue;\n\n\t\t\t\tlet array;\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'node':\n\t\t\t\t\t\tdata.nodes.push( child.getAttribute( 'id' ) );\n\t\t\t\t\t\tparseNode( child );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_camera':\n\t\t\t\t\t\tdata.instanceCameras.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_controller':\n\t\t\t\t\t\tdata.instanceControllers.push( parseNodeInstance( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_light':\n\t\t\t\t\t\tdata.instanceLights.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_geometry':\n\t\t\t\t\t\tdata.instanceGeometries.push( parseNodeInstance( child ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'instance_node':\n\t\t\t\t\t\tdata.instanceNodes.push( parseId( child.getAttribute( 'url' ) ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'matrix':\n\t\t\t\t\t\tarray = parseFloats( child.textContent );\n\t\t\t\t\t\tdata.matrix.multiply( matrix.fromArray( array ).transpose() );\n\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'translate':\n\t\t\t\t\t\tarray = parseFloats( child.textContent );\n\t\t\t\t\t\tvector.fromArray( array );\n\t\t\t\t\t\tdata.matrix.multiply( matrix.makeTranslation( vector.x, vector.y, vector.z ) );\n\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'rotate':\n\t\t\t\t\t\tarray = parseFloats( child.textContent );\n\t\t\t\t\t\tconst angle = MathUtils.degToRad( array[ 3 ] );\n\t\t\t\t\t\tdata.matrix.multiply( matrix.makeRotationAxis( vector.fromArray( array ), angle ) );\n\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'scale':\n\t\t\t\t\t\tarray = parseFloats( child.textContent );\n\t\t\t\t\t\tdata.matrix.scale( vector.fromArray( array ) );\n\t\t\t\t\t\tdata.transforms[ child.getAttribute( 'sid' ) ] = child.nodeName;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'extra':\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.log( child );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( hasNode( data.id ) ) {\n\n\t\t\t\tconsole.warn( 'THREE.ColladaLoader: There is already a node with ID %s. Exclude current node from further processing.', data.id );\n\n\t\t\t} else {\n\n\t\t\t\tlibrary.nodes[ data.id ] = data;\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction parseNodeInstance( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tid: parseId( xml.getAttribute( 'url' ) ),\n\t\t\t\tmaterials: {},\n\t\t\t\tskeletons: []\n\t\t\t};\n\n\t\t\tfor ( let i = 0; i < xml.childNodes.length; i ++ ) {\n\n\t\t\t\tconst child = xml.childNodes[ i ];\n\n\t\t\t\tswitch ( child.nodeName ) {\n\n\t\t\t\t\tcase 'bind_material':\n\t\t\t\t\t\tconst instances = child.getElementsByTagName( 'instance_material' );\n\n\t\t\t\t\t\tfor ( let j = 0; j < instances.length; j ++ ) {\n\n\t\t\t\t\t\t\tconst instance = instances[ j ];\n\t\t\t\t\t\t\tconst symbol = instance.getAttribute( 'symbol' );\n\t\t\t\t\t\t\tconst target = instance.getAttribute( 'target' );\n\n\t\t\t\t\t\t\tdata.materials[ symbol ] = parseId( target );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'skeleton':\n\t\t\t\t\t\tdata.skeletons.push( parseId( child.textContent ) );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\tfunction buildSkeleton( skeletons, joints ) {\n\n\t\t\tconst boneData = [];\n\t\t\tconst sortedBoneData = [];\n\n\t\t\tlet i, j, data;\n\n\t\t\t// a skeleton can have multiple root bones. collada expresses this\n\t\t\t// situtation with multiple \"skeleton\" tags per controller instance\n\n\t\t\tfor ( i = 0; i < skeletons.length; i ++ ) {\n\n\t\t\t\tconst skeleton = skeletons[ i ];\n\n\t\t\t\tlet root;\n\n\t\t\t\tif ( hasNode( skeleton ) ) {\n\n\t\t\t\t\troot = getNode( skeleton );\n\t\t\t\t\tbuildBoneHierarchy( root, joints, boneData );\n\n\t\t\t\t} else if ( hasVisualScene( skeleton ) ) {\n\n\t\t\t\t\t// handle case where the skeleton refers to the visual scene (#13335)\n\n\t\t\t\t\tconst visualScene = library.visualScenes[ skeleton ];\n\t\t\t\t\tconst children = visualScene.children;\n\n\t\t\t\t\tfor ( let j = 0; j < children.length; j ++ ) {\n\n\t\t\t\t\t\tconst child = children[ j ];\n\n\t\t\t\t\t\tif ( child.type === 'JOINT' ) {\n\n\t\t\t\t\t\t\tconst root = getNode( child.id );\n\t\t\t\t\t\t\tbuildBoneHierarchy( root, joints, boneData );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( 'THREE.ColladaLoader: Unable to find root bone of skeleton with ID:', skeleton );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// sort bone data (the order is defined in the corresponding controller)\n\n\t\t\tfor ( i = 0; i < joints.length; i ++ ) {\n\n\t\t\t\tfor ( j = 0; j < boneData.length; j ++ ) {\n\n\t\t\t\t\tdata = boneData[ j ];\n\n\t\t\t\t\tif ( data.bone.name === joints[ i ].name ) {\n\n\t\t\t\t\t\tsortedBoneData[ i ] = data;\n\t\t\t\t\t\tdata.processed = true;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add unprocessed bone data at the end of the list\n\n\t\t\tfor ( i = 0; i < boneData.length; i ++ ) {\n\n\t\t\t\tdata = boneData[ i ];\n\n\t\t\t\tif ( data.processed === false ) {\n\n\t\t\t\t\tsortedBoneData.push( data );\n\t\t\t\t\tdata.processed = true;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// setup arrays for skeleton creation\n\n\t\t\tconst bones = [];\n\t\t\tconst boneInverses = [];\n\n\t\t\tfor ( i = 0; i < sortedBoneData.length; i ++ ) {\n\n\t\t\t\tdata = sortedBoneData[ i ];\n\n\t\t\t\tbones.push( data.bone );\n\t\t\t\tboneInverses.push( data.boneInverse );\n\n\t\t\t}\n\n\t\t\treturn new Skeleton( bones, boneInverses );\n\n\t\t}\n\n\t\tfunction buildBoneHierarchy( root, joints, boneData ) {\n\n\t\t\t// setup bone data from visual scene\n\n\t\t\troot.traverse( function ( object ) {\n\n\t\t\t\tif ( object.isBone === true ) {\n\n\t\t\t\t\tlet boneInverse;\n\n\t\t\t\t\t// retrieve the boneInverse from the controller data\n\n\t\t\t\t\tfor ( let i = 0; i < joints.length; i ++ ) {\n\n\t\t\t\t\t\tconst joint = joints[ i ];\n\n\t\t\t\t\t\tif ( joint.name === object.name ) {\n\n\t\t\t\t\t\t\tboneInverse = joint.boneInverse;\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( boneInverse === undefined ) {\n\n\t\t\t\t\t\t// Unfortunately, there can be joints in the visual scene that are not part of the\n\t\t\t\t\t\t// corresponding controller. In this case, we have to create a dummy boneInverse matrix\n\t\t\t\t\t\t// for the respective bone. This bone won't affect any vertices, because there are no skin indices\n\t\t\t\t\t\t// and weights defined for it. But we still have to add the bone to the sorted bone list in order to\n\t\t\t\t\t\t// ensure a correct animation of the model.\n\n\t\t\t\t\t\tboneInverse = new Matrix4();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tboneData.push( { bone: object, boneInverse: boneInverse, processed: false } );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t}\n\n\t\tfunction buildNode( data ) {\n\n\t\t\tconst objects = [];\n\n\t\t\tconst matrix = data.matrix;\n\t\t\tconst nodes = data.nodes;\n\t\t\tconst type = data.type;\n\t\t\tconst instanceCameras = data.instanceCameras;\n\t\t\tconst instanceControllers = data.instanceControllers;\n\t\t\tconst instanceLights = data.instanceLights;\n\t\t\tconst instanceGeometries = data.instanceGeometries;\n\t\t\tconst instanceNodes = data.instanceNodes;\n\n\t\t\t// nodes\n\n\t\t\tfor ( let i = 0, l = nodes.length; i < l; i ++ ) {\n\n\t\t\t\tobjects.push( getNode( nodes[ i ] ) );\n\n\t\t\t}\n\n\t\t\t// instance cameras\n\n\t\t\tfor ( let i = 0, l = instanceCameras.length; i < l; i ++ ) {\n\n\t\t\t\tconst instanceCamera = getCamera( instanceCameras[ i ] );\n\n\t\t\t\tif ( instanceCamera !== null ) {\n\n\t\t\t\t\tobjects.push( instanceCamera.clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// instance controllers\n\n\t\t\tfor ( let i = 0, l = instanceControllers.length; i < l; i ++ ) {\n\n\t\t\t\tconst instance = instanceControllers[ i ];\n\t\t\t\tconst controller = getController( instance.id );\n\t\t\t\tconst geometries = getGeometry( controller.id );\n\t\t\t\tconst newObjects = buildObjects( geometries, instance.materials );\n\n\t\t\t\tconst skeletons = instance.skeletons;\n\t\t\t\tconst joints = controller.skin.joints;\n\n\t\t\t\tconst skeleton = buildSkeleton( skeletons, joints );\n\n\t\t\t\tfor ( let j = 0, jl = newObjects.length; j < jl; j ++ ) {\n\n\t\t\t\t\tconst object = newObjects[ j ];\n\n\t\t\t\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\t\t\t\tobject.bind( skeleton, controller.skin.bindMatrix );\n\t\t\t\t\t\tobject.normalizeSkinWeights();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tobjects.push( object );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// instance lights\n\n\t\t\tfor ( let i = 0, l = instanceLights.length; i < l; i ++ ) {\n\n\t\t\t\tconst instanceLight = getLight( instanceLights[ i ] );\n\n\t\t\t\tif ( instanceLight !== null ) {\n\n\t\t\t\t\tobjects.push( instanceLight.clone() );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// instance geometries\n\n\t\t\tfor ( let i = 0, l = instanceGeometries.length; i < l; i ++ ) {\n\n\t\t\t\tconst instance = instanceGeometries[ i ];\n\n\t\t\t\t// a single geometry instance in collada can lead to multiple object3Ds.\n\t\t\t\t// this is the case when primitives are combined like triangles and lines\n\n\t\t\t\tconst geometries = getGeometry( instance.id );\n\t\t\t\tconst newObjects = buildObjects( geometries, instance.materials );\n\n\t\t\t\tfor ( let j = 0, jl = newObjects.length; j < jl; j ++ ) {\n\n\t\t\t\t\tobjects.push( newObjects[ j ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// instance nodes\n\n\t\t\tfor ( let i = 0, l = instanceNodes.length; i < l; i ++ ) {\n\n\t\t\t\tobjects.push( getNode( instanceNodes[ i ] ).clone() );\n\n\t\t\t}\n\n\t\t\tlet object;\n\n\t\t\tif ( nodes.length === 0 && objects.length === 1 ) {\n\n\t\t\t\tobject = objects[ 0 ];\n\n\t\t\t} else {\n\n\t\t\t\tobject = ( type === 'JOINT' ) ? new Bone() : new Group();\n\n\t\t\t\tfor ( let i = 0; i < objects.length; i ++ ) {\n\n\t\t\t\t\tobject.add( objects[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tobject.name = ( type === 'JOINT' ) ? data.sid : data.name;\n\t\t\tobject.matrix.copy( matrix );\n\t\t\tobject.matrix.decompose( object.position, object.quaternion, object.scale );\n\n\t\t\treturn object;\n\n\t\t}\n\n\t\tconst fallbackMaterial = new MeshBasicMaterial( { color: 0xff00ff } );\n\n\t\tfunction resolveMaterialBinding( keys, instanceMaterials ) {\n\n\t\t\tconst materials = [];\n\n\t\t\tfor ( let i = 0, l = keys.length; i < l; i ++ ) {\n\n\t\t\t\tconst id = instanceMaterials[ keys[ i ] ];\n\n\t\t\t\tif ( id === undefined ) {\n\n\t\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Material with key %s not found. Apply fallback material.', keys[ i ] );\n\t\t\t\t\tmaterials.push( fallbackMaterial );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tmaterials.push( getMaterial( id ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn materials;\n\n\t\t}\n\n\t\tfunction buildObjects( geometries, instanceMaterials ) {\n\n\t\t\tconst objects = [];\n\n\t\t\tfor ( const type in geometries ) {\n\n\t\t\t\tconst geometry = geometries[ type ];\n\n\t\t\t\tconst materials = resolveMaterialBinding( geometry.materialKeys, instanceMaterials );\n\n\t\t\t\t// handle case if no materials are defined\n\n\t\t\t\tif ( materials.length === 0 ) {\n\n\t\t\t\t\tif ( type === 'lines' || type === 'linestrips' ) {\n\n\t\t\t\t\t\tmaterials.push( new LineBasicMaterial() );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmaterials.push( new MeshPhongMaterial() );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Collada allows to use phong and lambert materials with lines. Replacing these cases with LineBasicMaterial.\n\n\t\t\t\tif ( type === 'lines' || type === 'linestrips' ) {\n\n\t\t\t\t\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\t\t\t\t\tconst material = materials[ i ];\n\n\t\t\t\t\t\tif ( material.isMeshPhongMaterial === true || material.isMeshLambertMaterial === true ) {\n\n\t\t\t\t\t\t\tconst lineMaterial = new LineBasicMaterial();\n\n\t\t\t\t\t\t\t// copy compatible properties\n\n\t\t\t\t\t\t\tlineMaterial.color.copy( material.color );\n\t\t\t\t\t\t\tlineMaterial.opacity = material.opacity;\n\t\t\t\t\t\t\tlineMaterial.transparent = material.transparent;\n\n\t\t\t\t\t\t\t// replace material\n\n\t\t\t\t\t\t\tmaterials[ i ] = lineMaterial;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// regard skinning\n\n\t\t\t\tconst skinning = ( geometry.data.attributes.skinIndex !== undefined );\n\n\t\t\t\t// choose between a single or multi materials (material array)\n\n\t\t\t\tconst material = ( materials.length === 1 ) ? materials[ 0 ] : materials;\n\n\t\t\t\t// now create a specific 3D object\n\n\t\t\t\tlet object;\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase 'lines':\n\t\t\t\t\t\tobject = new LineSegments( geometry.data, material );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'linestrips':\n\t\t\t\t\t\tobject = new Line( geometry.data, material );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'triangles':\n\t\t\t\t\tcase 'polylist':\n\t\t\t\t\t\tif ( skinning ) {\n\n\t\t\t\t\t\t\tobject = new SkinnedMesh( geometry.data, material );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tobject = new Mesh( geometry.data, material );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t\tobjects.push( object );\n\n\t\t\t}\n\n\t\t\treturn objects;\n\n\t\t}\n\n\t\tfunction hasNode( id ) {\n\n\t\t\treturn library.nodes[ id ] !== undefined;\n\n\t\t}\n\n\t\tfunction getNode( id ) {\n\n\t\t\treturn getBuild( library.nodes[ id ], buildNode );\n\n\t\t}\n\n\t\t// visual scenes\n\n\t\tfunction parseVisualScene( xml ) {\n\n\t\t\tconst data = {\n\t\t\t\tname: xml.getAttribute( 'name' ),\n\t\t\t\tchildren: []\n\t\t\t};\n\n\t\t\tprepareNodes( xml );\n\n\t\t\tconst elements = getElementsByTagName( xml, 'node' );\n\n\t\t\tfor ( let i = 0; i < elements.length; i ++ ) {\n\n\t\t\t\tdata.children.push( parseNode( elements[ i ] ) );\n\n\t\t\t}\n\n\t\t\tlibrary.visualScenes[ xml.getAttribute( 'id' ) ] = data;\n\n\t\t}\n\n\t\tfunction buildVisualScene( data ) {\n\n\t\t\tconst group = new Group();\n\t\t\tgroup.name = data.name;\n\n\t\t\tconst children = data.children;\n\n\t\t\tfor ( let i = 0; i < children.length; i ++ ) {\n\n\t\t\t\tconst child = children[ i ];\n\n\t\t\t\tgroup.add( getNode( child.id ) );\n\n\t\t\t}\n\n\t\t\treturn group;\n\n\t\t}\n\n\t\tfunction hasVisualScene( id ) {\n\n\t\t\treturn library.visualScenes[ id ] !== undefined;\n\n\t\t}\n\n\t\tfunction getVisualScene( id ) {\n\n\t\t\treturn getBuild( library.visualScenes[ id ], buildVisualScene );\n\n\t\t}\n\n\t\t// scenes\n\n\t\tfunction parseScene( xml ) {\n\n\t\t\tconst instance = getElementsByTagName( xml, 'instance_visual_scene' )[ 0 ];\n\t\t\treturn getVisualScene( parseId( instance.getAttribute( 'url' ) ) );\n\n\t\t}\n\n\t\tfunction setupAnimations() {\n\n\t\t\tconst clips = library.clips;\n\n\t\t\tif ( isEmpty( clips ) === true ) {\n\n\t\t\t\tif ( isEmpty( library.animations ) === false ) {\n\n\t\t\t\t\t// if there are animations but no clips, we create a default clip for playback\n\n\t\t\t\t\tconst tracks = [];\n\n\t\t\t\t\tfor ( const id in library.animations ) {\n\n\t\t\t\t\t\tconst animationTracks = getAnimation( id );\n\n\t\t\t\t\t\tfor ( let i = 0, l = animationTracks.length; i < l; i ++ ) {\n\n\t\t\t\t\t\t\ttracks.push( animationTracks[ i ] );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tanimations.push( new AnimationClip( 'default', - 1, tracks ) );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tfor ( const id in clips ) {\n\n\t\t\t\t\tanimations.push( getAnimationClip( id ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// convert the parser error element into text with each child elements text\n\t\t// separated by new lines.\n\n\t\tfunction parserErrorToText( parserError ) {\n\n\t\t\tlet result = '';\n\t\t\tconst stack = [ parserError ];\n\n\t\t\twhile ( stack.length ) {\n\n\t\t\t\tconst node = stack.shift();\n\n\t\t\t\tif ( node.nodeType === Node.TEXT_NODE ) {\n\n\t\t\t\t\tresult += node.textContent;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tresult += '\\n';\n\t\t\t\t\tstack.push.apply( stack, node.childNodes );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn result.trim();\n\n\t\t}\n\n\t\tif ( text.length === 0 ) {\n\n\t\t\treturn { scene: new Scene() };\n\n\t\t}\n\n\t\tconst xml = new DOMParser().parseFromString( text, 'application/xml' );\n\n\t\tconst collada = getElementsByTagName( xml, 'COLLADA' )[ 0 ];\n\n\t\tconst parserError = xml.getElementsByTagName( 'parsererror' )[ 0 ];\n\t\tif ( parserError !== undefined ) {\n\n\t\t\t// Chrome will return parser error with a div in it\n\n\t\t\tconst errorElement = getElementsByTagName( parserError, 'div' )[ 0 ];\n\t\t\tlet errorText;\n\n\t\t\tif ( errorElement ) {\n\n\t\t\t\terrorText = errorElement.textContent;\n\n\t\t\t} else {\n\n\t\t\t\terrorText = parserErrorToText( parserError );\n\n\t\t\t}\n\n\t\t\tconsole.error( 'THREE.ColladaLoader: Failed to parse collada file.\\n', errorText );\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// metadata\n\n\t\tconst version = collada.getAttribute( 'version' );\n\t\tconsole.debug( 'THREE.ColladaLoader: File version', version );\n\n\t\tconst asset = parseAsset( getElementsByTagName( collada, 'asset' )[ 0 ] );\n\t\tconst textureLoader = new TextureLoader( this.manager );\n\t\ttextureLoader.setPath( this.resourcePath || path ).setCrossOrigin( this.crossOrigin );\n\n\t\tlet tgaLoader;\n\n\t\tif ( TGALoader ) {\n\n\t\t\ttgaLoader = new TGALoader( this.manager );\n\t\t\ttgaLoader.setPath( this.resourcePath || path );\n\n\t\t}\n\n\t\t//\n\n\t\tconst tempColor = new Color();\n\t\tconst animations = [];\n\t\tlet kinematics = {};\n\t\tlet count = 0;\n\n\t\t//\n\n\t\tconst library = {\n\t\t\tanimations: {},\n\t\t\tclips: {},\n\t\t\tcontrollers: {},\n\t\t\timages: {},\n\t\t\teffects: {},\n\t\t\tmaterials: {},\n\t\t\tcameras: {},\n\t\t\tlights: {},\n\t\t\tgeometries: {},\n\t\t\tnodes: {},\n\t\t\tvisualScenes: {},\n\t\t\tkinematicsModels: {},\n\t\t\tphysicsModels: {},\n\t\t\tkinematicsScenes: {}\n\t\t};\n\n\t\tparseLibrary( collada, 'library_animations', 'animation', parseAnimation );\n\t\tparseLibrary( collada, 'library_animation_clips', 'animation_clip', parseAnimationClip );\n\t\tparseLibrary( collada, 'library_controllers', 'controller', parseController );\n\t\tparseLibrary( collada, 'library_images', 'image', parseImage );\n\t\tparseLibrary( collada, 'library_effects', 'effect', parseEffect );\n\t\tparseLibrary( collada, 'library_materials', 'material', parseMaterial );\n\t\tparseLibrary( collada, 'library_cameras', 'camera', parseCamera );\n\t\tparseLibrary( collada, 'library_lights', 'light', parseLight );\n\t\tparseLibrary( collada, 'library_geometries', 'geometry', parseGeometry );\n\t\tparseLibrary( collada, 'library_nodes', 'node', parseNode );\n\t\tparseLibrary( collada, 'library_visual_scenes', 'visual_scene', parseVisualScene );\n\t\tparseLibrary( collada, 'library_kinematics_models', 'kinematics_model', parseKinematicsModel );\n\t\tparseLibrary( collada, 'library_physics_models', 'physics_model', parsePhysicsModel );\n\t\tparseLibrary( collada, 'scene', 'instance_kinematics_scene', parseKinematicsScene );\n\n\t\tbuildLibrary( library.animations, buildAnimation );\n\t\tbuildLibrary( library.clips, buildAnimationClip );\n\t\tbuildLibrary( library.controllers, buildController );\n\t\tbuildLibrary( library.images, buildImage );\n\t\tbuildLibrary( library.effects, buildEffect );\n\t\tbuildLibrary( library.materials, buildMaterial );\n\t\tbuildLibrary( library.cameras, buildCamera );\n\t\tbuildLibrary( library.lights, buildLight );\n\t\tbuildLibrary( library.geometries, buildGeometry );\n\t\tbuildLibrary( library.visualScenes, buildVisualScene );\n\n\t\tsetupAnimations();\n\t\tsetupKinematics();\n\n\t\tconst scene = parseScene( getElementsByTagName( collada, 'scene' )[ 0 ] );\n\t\tscene.animations = animations;\n\n\t\tif ( asset.upAxis === 'Z_UP' ) {\n\n\t\t\tconsole.warn( 'THREE.ColladaLoader: You are loading an asset with a Z-UP coordinate system. The loader just rotates the asset to transform it into Y-UP. The vertex data are not converted, see #24289.' );\n\t\t\tscene.rotation.set( - Math.PI / 2, 0, 0 );\n\n\t\t}\n\n\t\tscene.scale.multiplyScalar( asset.unit );\n\n\t\treturn {\n\t\t\tget animations() {\n\n\t\t\t\tconsole.warn( 'THREE.ColladaLoader: Please access animations over scene.animations now.' );\n\t\t\t\treturn animations;\n\n\t\t\t},\n\t\t\tkinematics: kinematics,\n\t\t\tlibrary: library,\n\t\t\tscene: scene\n\t\t};\n\n\t}\n\n}\n\nexport { ColladaLoader };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
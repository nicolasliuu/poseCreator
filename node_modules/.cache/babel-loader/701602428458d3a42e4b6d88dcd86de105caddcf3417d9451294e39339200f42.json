{"ast":null,"code":"import * as THREE from 'three';\nimport { STLLoader } from 'three/examples/jsm/loaders/STLLoader.js';\nimport { ColladaLoader } from 'three/examples/jsm/loaders/ColladaLoader.js';\nimport { URDFRobot, URDFJoint, URDFLink, URDFCollider, URDFVisual, URDFMimicJoint } from './URDFClasses.js';\n\n/*\nReference coordinate frames for THREE.js and ROS.\nBoth coordinate systems are right handed so the URDF is instantiated without\nframe transforms. The resulting model can be rotated to rectify the proper up,\nright, and forward directions\n\nTHREE.js\n   Y\n   |\n   |\n   .-----X\n ／\nZ\n\nROS URDf\n       Z\n       |   X\n       | ／\n Y-----.\n\n*/\n\nconst tempQuaternion = new THREE.Quaternion();\nconst tempEuler = new THREE.Euler();\n\n// take a vector \"x y z\" and process it into\n// an array [x, y, z]\nfunction processTuple(val) {\n  if (!val) return [0, 0, 0];\n  return val.trim().split(/\\s+/g).map(num => parseFloat(num));\n}\n\n// applies a rotation a threejs object in URDF order\nfunction applyRotation(obj, rpy) {\n  let additive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  // if additive is true the rotation is applied in\n  // addition to the existing rotation\n  if (!additive) obj.rotation.set(0, 0, 0);\n  tempEuler.set(rpy[0], rpy[1], rpy[2], 'ZYX');\n  tempQuaternion.setFromEuler(tempEuler);\n  tempQuaternion.multiply(obj.quaternion);\n  obj.quaternion.copy(tempQuaternion);\n}\n\n/* URDFLoader Class */\n// Loads and reads a URDF file into a THREEjs Object3D format\nexport default class URDFLoader {\n  constructor(manager) {\n    this.manager = manager || THREE.DefaultLoadingManager;\n    this.loadMeshCb = this.defaultMeshLoader.bind(this);\n    this.parseVisual = true;\n    this.parseCollision = false;\n    this.packages = '';\n    this.workingPath = '';\n    this.fetchOptions = {};\n  }\n\n  /* Public API */\n  loadAsync(urdf) {\n    return new Promise((resolve, reject) => {\n      this.load(urdf, resolve, null, reject);\n    });\n  }\n\n  // urdf:    The path to the URDF within the package OR absolute\n  // onComplete:      Callback that is passed the model once loaded\n  load(urdf, onComplete, onProgress, onError) {\n    // Check if a full URI is specified before\n    // prepending the package info\n    const manager = this.manager;\n    const workingPath = THREE.LoaderUtils.extractUrlBase(urdf);\n    const urdfPath = this.manager.resolveURL(urdf);\n    manager.itemStart(urdfPath);\n    fetch(urdfPath, this.fetchOptions).then(res => {\n      if (res.ok) {\n        if (onProgress) {\n          onProgress(null);\n        }\n        return res.text();\n      } else {\n        throw new Error(`URDFLoader: Failed to load url '${urdfPath}' with error code ${res.status} : ${res.statusText}.`);\n      }\n    }).then(data => {\n      if (this.workingPath === '') {\n        this.workingPath = workingPath;\n      }\n      const model = this.parse(data);\n      onComplete(model);\n      manager.itemEnd(urdfPath);\n    }).catch(e => {\n      if (onError) {\n        onError(e);\n      } else {\n        console.error('URDFLoader: Error loading file.', e);\n      }\n      manager.itemError(urdfPath);\n      manager.itemEnd(urdfPath);\n    });\n  }\n  parse(content) {\n    const packages = this.packages;\n    const loadMeshCb = this.loadMeshCb;\n    const parseVisual = this.parseVisual;\n    const parseCollision = this.parseCollision;\n    const workingPath = this.workingPath;\n    const manager = this.manager;\n    const linkMap = {};\n    const jointMap = {};\n    const materialMap = {};\n\n    // Resolves the path of mesh files\n    function resolvePath(path) {\n      if (!/^package:\\/\\//.test(path)) {\n        return workingPath ? workingPath + path : path;\n      }\n\n      // Remove \"package://\" keyword and split meshPath at the first slash\n      const [targetPkg, relPath] = path.replace(/^package:\\/\\//, '').split(/\\/(.+)/);\n      if (typeof packages === 'string') {\n        // \"pkg\" is one single package\n        if (packages.endsWith(targetPkg)) {\n          // \"pkg\" is the target package\n          return packages + '/' + relPath;\n        } else {\n          // Assume \"pkg\" is the target package's parent directory\n          return packages + '/' + targetPkg + '/' + relPath;\n        }\n      } else if (packages instanceof Function) {\n        return packages(targetPkg) + '/' + relPath;\n      } else if (typeof packages === 'object') {\n        // \"pkg\" is a map of packages\n        if (targetPkg in packages) {\n          return packages[targetPkg] + '/' + relPath;\n        } else {\n          console.error(`URDFLoader : ${targetPkg} not found in provided package list.`);\n          return null;\n        }\n      }\n    }\n\n    // Process the URDF text format\n    function processUrdf(data) {\n      let children;\n      if (data instanceof Document) {\n        children = [...data.children];\n      } else if (data instanceof Element) {\n        children = [data];\n      } else {\n        const parser = new DOMParser();\n        const urdf = parser.parseFromString(data, 'text/xml');\n        children = [...urdf.children];\n      }\n      const robotNode = children.filter(c => c.nodeName === 'robot').pop();\n      return processRobot(robotNode);\n    }\n\n    // Process the <robot> node\n    function processRobot(robot) {\n      const robotNodes = [...robot.children];\n      const links = robotNodes.filter(c => c.nodeName.toLowerCase() === 'link');\n      const joints = robotNodes.filter(c => c.nodeName.toLowerCase() === 'joint');\n      const materials = robotNodes.filter(c => c.nodeName.toLowerCase() === 'material');\n      const obj = new URDFRobot();\n      obj.robotName = robot.getAttribute('name');\n      obj.urdfRobotNode = robot;\n\n      // Create the <material> map\n      materials.forEach(m => {\n        const name = m.getAttribute('name');\n        materialMap[name] = processMaterial(m);\n      });\n\n      // Create the <link> map\n      const visualMap = {};\n      const colliderMap = {};\n      links.forEach(l => {\n        const name = l.getAttribute('name');\n        const isRoot = robot.querySelector(`child[link=\"${name}\"]`) === null;\n        linkMap[name] = processLink(l, visualMap, colliderMap, isRoot ? obj : null);\n      });\n\n      // Create the <joint> map\n      joints.forEach(j => {\n        const name = j.getAttribute('name');\n        jointMap[name] = processJoint(j);\n      });\n      obj.joints = jointMap;\n      obj.links = linkMap;\n      obj.colliders = colliderMap;\n      obj.visual = visualMap;\n\n      // Link up mimic joints\n      const jointList = Object.values(jointMap);\n      jointList.forEach(j => {\n        if (j instanceof URDFMimicJoint) {\n          jointMap[j.mimicJoint].mimicJoints.push(j);\n        }\n      });\n\n      // Detect infinite loops of mimic joints\n      jointList.forEach(j => {\n        const uniqueJoints = new Set();\n        const iterFunction = joint => {\n          if (uniqueJoints.has(joint)) {\n            throw new Error('URDFLoader: Detected an infinite loop of mimic joints.');\n          }\n          uniqueJoints.add(joint);\n          joint.mimicJoints.forEach(j => {\n            iterFunction(j);\n          });\n        };\n        iterFunction(j);\n      });\n      obj.frames = {\n        ...colliderMap,\n        ...visualMap,\n        ...linkMap,\n        ...jointMap\n      };\n      return obj;\n    }\n\n    // Process joint nodes and parent them\n    function processJoint(joint) {\n      const children = [...joint.children];\n      const jointType = joint.getAttribute('type');\n      let obj;\n      const mimicTag = children.find(n => n.nodeName.toLowerCase() === 'mimic');\n      if (mimicTag) {\n        obj = new URDFMimicJoint();\n        obj.mimicJoint = mimicTag.getAttribute('joint');\n        obj.multiplier = parseFloat(mimicTag.getAttribute('multiplier') || 1.0);\n        obj.offset = parseFloat(mimicTag.getAttribute('offset') || 0.0);\n      } else {\n        obj = new URDFJoint();\n      }\n      obj.urdfNode = joint;\n      obj.name = joint.getAttribute('name');\n      obj.urdfName = obj.name;\n      obj.jointType = jointType;\n      let parent = null;\n      let child = null;\n      let xyz = [0, 0, 0];\n      let rpy = [0, 0, 0];\n\n      // Extract the attributes\n      children.forEach(n => {\n        const type = n.nodeName.toLowerCase();\n        if (type === 'origin') {\n          xyz = processTuple(n.getAttribute('xyz'));\n          rpy = processTuple(n.getAttribute('rpy'));\n        } else if (type === 'child') {\n          child = linkMap[n.getAttribute('link')];\n        } else if (type === 'parent') {\n          parent = linkMap[n.getAttribute('link')];\n        } else if (type === 'limit') {\n          obj.limit.lower = parseFloat(n.getAttribute('lower') || obj.limit.lower);\n          obj.limit.upper = parseFloat(n.getAttribute('upper') || obj.limit.upper);\n        }\n      });\n\n      // Join the links\n      parent.add(obj);\n      obj.add(child);\n      applyRotation(obj, rpy);\n      obj.position.set(xyz[0], xyz[1], xyz[2]);\n\n      // Set up the rotate function\n      const axisNode = children.filter(n => n.nodeName.toLowerCase() === 'axis')[0];\n      if (axisNode) {\n        const axisXYZ = axisNode.getAttribute('xyz').split(/\\s+/g).map(num => parseFloat(num));\n        obj.axis = new THREE.Vector3(axisXYZ[0], axisXYZ[1], axisXYZ[2]);\n        obj.axis.normalize();\n      }\n      return obj;\n    }\n\n    // Process the <link> nodes\n    function processLink(link, visualMap, colliderMap) {\n      let target = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n      if (target === null) {\n        target = new URDFLink();\n      }\n      const children = [...link.children];\n      target.name = link.getAttribute('name');\n      target.urdfName = target.name;\n      target.urdfNode = link;\n      if (parseVisual) {\n        const visualNodes = children.filter(n => n.nodeName.toLowerCase() === 'visual');\n        visualNodes.forEach(vn => {\n          const v = processLinkElement(vn, materialMap);\n          target.add(v);\n          if (vn.hasAttribute('name')) {\n            const name = vn.getAttribute('name');\n            v.name = name;\n            v.urdfName = name;\n            visualMap[name] = v;\n          }\n        });\n      }\n      if (parseCollision) {\n        const collisionNodes = children.filter(n => n.nodeName.toLowerCase() === 'collision');\n        collisionNodes.forEach(cn => {\n          const c = processLinkElement(cn);\n          target.add(c);\n          if (cn.hasAttribute('name')) {\n            const name = cn.getAttribute('name');\n            c.name = name;\n            c.urdfName = name;\n            colliderMap[name] = c;\n          }\n        });\n      }\n      return target;\n    }\n    function processMaterial(node) {\n      const matNodes = [...node.children];\n      const material = new THREE.MeshPhongMaterial();\n      material.name = node.getAttribute('name') || '';\n      matNodes.forEach(n => {\n        const type = n.nodeName.toLowerCase();\n        if (type === 'color') {\n          const rgba = n.getAttribute('rgba').split(/\\s/g).map(v => parseFloat(v));\n          material.color.setRGB(rgba[0], rgba[1], rgba[2]).convertSRGBToLinear();\n          material.opacity = rgba[3];\n          material.transparent = rgba[3] < 1;\n          material.depthWrite = !material.transparent;\n        } else if (type === 'texture') {\n          // The URDF spec does not require that the <texture/> tag include\n          // a filename attribute so skip loading the texture if not provided.\n          const filename = n.getAttribute('filename');\n          if (filename) {\n            const loader = new THREE.TextureLoader(manager);\n            const filePath = resolvePath(filename);\n            material.map = loader.load(filePath);\n            material.map.encoding = THREE.sRGBEncoding;\n          }\n        }\n      });\n      return material;\n    }\n\n    // Process the visual and collision nodes into meshes\n    function processLinkElement(vn) {\n      let materialMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      const isCollisionNode = vn.nodeName.toLowerCase() === 'collision';\n      const children = [...vn.children];\n      let material = null;\n\n      // get the material first\n      const materialNode = children.filter(n => n.nodeName.toLowerCase() === 'material')[0];\n      if (materialNode) {\n        const name = materialNode.getAttribute('name');\n        if (name && name in materialMap) {\n          material = materialMap[name];\n        } else {\n          material = processMaterial(materialNode);\n        }\n      } else {\n        material = new THREE.MeshPhongMaterial();\n      }\n      const group = isCollisionNode ? new URDFCollider() : new URDFVisual();\n      group.urdfNode = vn;\n      children.forEach(n => {\n        const type = n.nodeName.toLowerCase();\n        if (type === 'geometry') {\n          const geoType = n.children[0].nodeName.toLowerCase();\n          if (geoType === 'mesh') {\n            const filename = n.children[0].getAttribute('filename');\n            const filePath = resolvePath(filename);\n\n            // file path is null if a package directory is not provided.\n            if (filePath !== null) {\n              const scaleAttr = n.children[0].getAttribute('scale');\n              if (scaleAttr) {\n                const scale = processTuple(scaleAttr);\n                group.scale.set(scale[0], scale[1], scale[2]);\n              }\n              loadMeshCb(filePath, manager, (obj, err) => {\n                if (err) {\n                  console.error('URDFLoader: Error loading mesh.', err);\n                } else if (obj) {\n                  if (obj instanceof THREE.Mesh) {\n                    obj.material = material;\n                  }\n\n                  // We don't expect non identity rotations or positions. In the case of\n                  // COLLADA files the model might come in with a custom scale for unit\n                  // conversion.\n                  obj.position.set(0, 0, 0);\n                  obj.quaternion.identity();\n                  group.add(obj);\n                }\n              });\n            }\n          } else if (geoType === 'box') {\n            const primitiveModel = new THREE.Mesh();\n            primitiveModel.geometry = new THREE.BoxBufferGeometry(1, 1, 1);\n            primitiveModel.material = material;\n            const size = processTuple(n.children[0].getAttribute('size'));\n            primitiveModel.scale.set(size[0], size[1], size[2]);\n            group.add(primitiveModel);\n          } else if (geoType === 'sphere') {\n            const primitiveModel = new THREE.Mesh();\n            primitiveModel.geometry = new THREE.SphereBufferGeometry(1, 30, 30);\n            primitiveModel.material = material;\n            const radius = parseFloat(n.children[0].getAttribute('radius')) || 0;\n            primitiveModel.scale.set(radius, radius, radius);\n            group.add(primitiveModel);\n          } else if (geoType === 'cylinder') {\n            const primitiveModel = new THREE.Mesh();\n            primitiveModel.geometry = new THREE.CylinderBufferGeometry(1, 1, 1, 30);\n            primitiveModel.material = material;\n            const radius = parseFloat(n.children[0].getAttribute('radius')) || 0;\n            const length = parseFloat(n.children[0].getAttribute('length')) || 0;\n            primitiveModel.scale.set(radius, length, radius);\n            primitiveModel.rotation.set(Math.PI / 2, 0, 0);\n            group.add(primitiveModel);\n          }\n        } else if (type === 'origin') {\n          const xyz = processTuple(n.getAttribute('xyz'));\n          const rpy = processTuple(n.getAttribute('rpy'));\n          group.position.set(xyz[0], xyz[1], xyz[2]);\n          group.rotation.set(0, 0, 0);\n          applyRotation(group, rpy);\n        }\n      });\n      return group;\n    }\n    return processUrdf(content);\n  }\n\n  // Default mesh loading function\n  defaultMeshLoader(path, manager, done) {\n    if (/\\.stl$/i.test(path)) {\n      const loader = new STLLoader(manager);\n      loader.load(path, geom => {\n        const mesh = new THREE.Mesh(geom, new THREE.MeshPhongMaterial());\n        done(mesh);\n      });\n    } else if (/\\.dae$/i.test(path)) {\n      const loader = new ColladaLoader(manager);\n      loader.load(path, dae => done(dae.scene));\n    } else {\n      console.warn(`URDFLoader: Could not load model at ${path}.\\nNo loader available`);\n    }\n  }\n}\n;","map":{"version":3,"names":["THREE","STLLoader","ColladaLoader","URDFRobot","URDFJoint","URDFLink","URDFCollider","URDFVisual","URDFMimicJoint","tempQuaternion","Quaternion","tempEuler","Euler","processTuple","val","trim","split","map","num","parseFloat","applyRotation","obj","rpy","additive","arguments","length","undefined","rotation","set","setFromEuler","multiply","quaternion","copy","URDFLoader","constructor","manager","DefaultLoadingManager","loadMeshCb","defaultMeshLoader","bind","parseVisual","parseCollision","packages","workingPath","fetchOptions","loadAsync","urdf","Promise","resolve","reject","load","onComplete","onProgress","onError","LoaderUtils","extractUrlBase","urdfPath","resolveURL","itemStart","fetch","then","res","ok","text","Error","status","statusText","data","model","parse","itemEnd","catch","e","console","error","itemError","content","linkMap","jointMap","materialMap","resolvePath","path","test","targetPkg","relPath","replace","endsWith","Function","processUrdf","children","Document","Element","parser","DOMParser","parseFromString","robotNode","filter","c","nodeName","pop","processRobot","robot","robotNodes","links","toLowerCase","joints","materials","robotName","getAttribute","urdfRobotNode","forEach","m","name","processMaterial","visualMap","colliderMap","l","isRoot","querySelector","processLink","j","processJoint","colliders","visual","jointList","Object","values","mimicJoint","mimicJoints","push","uniqueJoints","Set","iterFunction","joint","has","add","frames","jointType","mimicTag","find","n","multiplier","offset","urdfNode","urdfName","parent","child","xyz","type","limit","lower","upper","position","axisNode","axisXYZ","axis","Vector3","normalize","link","target","visualNodes","vn","v","processLinkElement","hasAttribute","collisionNodes","cn","node","matNodes","material","MeshPhongMaterial","rgba","color","setRGB","convertSRGBToLinear","opacity","transparent","depthWrite","filename","loader","TextureLoader","filePath","encoding","sRGBEncoding","isCollisionNode","materialNode","group","geoType","scaleAttr","scale","err","Mesh","identity","primitiveModel","geometry","BoxBufferGeometry","size","SphereBufferGeometry","radius","CylinderBufferGeometry","Math","PI","done","geom","mesh","dae","scene","warn"],"sources":["/Users/nicolas/Documents/pose-creator/node_modules/urdf-loader/src/URDFLoader.js"],"sourcesContent":["import * as THREE from 'three';\nimport { STLLoader } from 'three/examples/jsm/loaders/STLLoader.js';\nimport { ColladaLoader } from 'three/examples/jsm/loaders/ColladaLoader.js';\nimport { URDFRobot, URDFJoint, URDFLink, URDFCollider, URDFVisual, URDFMimicJoint } from './URDFClasses.js';\n\n/*\nReference coordinate frames for THREE.js and ROS.\nBoth coordinate systems are right handed so the URDF is instantiated without\nframe transforms. The resulting model can be rotated to rectify the proper up,\nright, and forward directions\n\nTHREE.js\n   Y\n   |\n   |\n   .-----X\n ／\nZ\n\nROS URDf\n       Z\n       |   X\n       | ／\n Y-----.\n\n*/\n\nconst tempQuaternion = new THREE.Quaternion();\nconst tempEuler = new THREE.Euler();\n\n// take a vector \"x y z\" and process it into\n// an array [x, y, z]\nfunction processTuple(val) {\n\n    if (!val) return [0, 0, 0];\n    return val.trim().split(/\\s+/g).map(num => parseFloat(num));\n\n}\n\n// applies a rotation a threejs object in URDF order\nfunction applyRotation(obj, rpy, additive = false) {\n\n    // if additive is true the rotation is applied in\n    // addition to the existing rotation\n    if (!additive) obj.rotation.set(0, 0, 0);\n\n    tempEuler.set(rpy[0], rpy[1], rpy[2], 'ZYX');\n    tempQuaternion.setFromEuler(tempEuler);\n    tempQuaternion.multiply(obj.quaternion);\n    obj.quaternion.copy(tempQuaternion);\n\n}\n\n/* URDFLoader Class */\n// Loads and reads a URDF file into a THREEjs Object3D format\nexport default\nclass URDFLoader {\n\n    constructor(manager) {\n\n        this.manager = manager || THREE.DefaultLoadingManager;\n        this.loadMeshCb = this.defaultMeshLoader.bind(this);\n        this.parseVisual = true;\n        this.parseCollision = false;\n        this.packages = '';\n        this.workingPath = '';\n        this.fetchOptions = {};\n\n    }\n\n    /* Public API */\n    loadAsync(urdf) {\n\n        return new Promise((resolve, reject) => {\n\n            this.load(urdf, resolve, null, reject);\n\n        });\n\n    }\n\n    // urdf:    The path to the URDF within the package OR absolute\n    // onComplete:      Callback that is passed the model once loaded\n    load(urdf, onComplete, onProgress, onError) {\n\n        // Check if a full URI is specified before\n        // prepending the package info\n        const manager = this.manager;\n        const workingPath = THREE.LoaderUtils.extractUrlBase(urdf);\n        const urdfPath = this.manager.resolveURL(urdf);\n\n        manager.itemStart(urdfPath);\n\n        fetch(urdfPath, this.fetchOptions)\n            .then(res => {\n\n                if (res.ok) {\n\n                    if (onProgress) {\n\n                        onProgress(null);\n\n                    }\n                    return res.text();\n\n                } else {\n\n                    throw new Error(`URDFLoader: Failed to load url '${ urdfPath }' with error code ${ res.status } : ${ res.statusText }.`);\n\n                }\n\n            })\n            .then(data => {\n\n                if (this.workingPath === '') {\n\n                    this.workingPath = workingPath;\n\n                }\n\n                const model = this.parse(data);\n                onComplete(model);\n                manager.itemEnd(urdfPath);\n\n            })\n            .catch(e => {\n\n                if (onError) {\n\n                    onError(e);\n\n                } else {\n\n                    console.error('URDFLoader: Error loading file.', e);\n\n                }\n                manager.itemError(urdfPath);\n                manager.itemEnd(urdfPath);\n\n            });\n\n    }\n\n    parse(content) {\n\n        const packages = this.packages;\n        const loadMeshCb = this.loadMeshCb;\n        const parseVisual = this.parseVisual;\n        const parseCollision = this.parseCollision;\n        const workingPath = this.workingPath;\n        const manager = this.manager;\n        const linkMap = {};\n        const jointMap = {};\n        const materialMap = {};\n\n        // Resolves the path of mesh files\n        function resolvePath(path) {\n\n            if (!/^package:\\/\\//.test(path)) {\n\n                return workingPath ? workingPath + path : path;\n\n            }\n\n            // Remove \"package://\" keyword and split meshPath at the first slash\n            const [targetPkg, relPath] = path.replace(/^package:\\/\\//, '').split(/\\/(.+)/);\n\n            if (typeof packages === 'string') {\n\n                // \"pkg\" is one single package\n                if (packages.endsWith(targetPkg)) {\n\n                    // \"pkg\" is the target package\n                    return packages + '/' + relPath;\n\n                } else {\n\n                    // Assume \"pkg\" is the target package's parent directory\n                    return packages + '/' + targetPkg + '/' + relPath;\n\n                }\n\n            } else if (packages instanceof Function) {\n\n                return packages(targetPkg) + '/' + relPath;\n\n            } else if (typeof packages === 'object') {\n\n                // \"pkg\" is a map of packages\n                if (targetPkg in packages) {\n\n                    return packages[targetPkg] + '/' + relPath;\n\n                } else {\n\n                    console.error(`URDFLoader : ${ targetPkg } not found in provided package list.`);\n                    return null;\n\n                }\n\n            }\n\n        }\n\n        // Process the URDF text format\n        function processUrdf(data) {\n\n            let children;\n            if (data instanceof Document) {\n\n                children = [ ...data.children ];\n\n            } else if (data instanceof Element) {\n\n                children = [ data ];\n\n            } else {\n\n                const parser = new DOMParser();\n                const urdf = parser.parseFromString(data, 'text/xml');\n                children = [ ...urdf.children ];\n\n            }\n\n            const robotNode = children.filter(c => c.nodeName === 'robot').pop();\n            return processRobot(robotNode);\n\n        }\n\n        // Process the <robot> node\n        function processRobot(robot) {\n\n            const robotNodes = [ ...robot.children ];\n            const links = robotNodes.filter(c => c.nodeName.toLowerCase() === 'link');\n            const joints = robotNodes.filter(c => c.nodeName.toLowerCase() === 'joint');\n            const materials = robotNodes.filter(c => c.nodeName.toLowerCase() === 'material');\n            const obj = new URDFRobot();\n\n            obj.robotName = robot.getAttribute('name');\n            obj.urdfRobotNode = robot;\n\n            // Create the <material> map\n            materials.forEach(m => {\n\n                const name = m.getAttribute('name');\n                materialMap[name] = processMaterial(m);\n\n            });\n\n            // Create the <link> map\n            const visualMap = {};\n            const colliderMap = {};\n            links.forEach(l => {\n\n                const name = l.getAttribute('name');\n                const isRoot = robot.querySelector(`child[link=\"${ name }\"]`) === null;\n                linkMap[name] = processLink(l, visualMap, colliderMap, isRoot ? obj : null);\n\n            });\n\n            // Create the <joint> map\n            joints.forEach(j => {\n\n                const name = j.getAttribute('name');\n                jointMap[name] = processJoint(j);\n\n            });\n\n            obj.joints = jointMap;\n            obj.links = linkMap;\n            obj.colliders = colliderMap;\n            obj.visual = visualMap;\n\n            // Link up mimic joints\n            const jointList = Object.values(jointMap);\n            jointList.forEach(j => {\n\n                if (j instanceof URDFMimicJoint) {\n\n                    jointMap[j.mimicJoint].mimicJoints.push(j);\n\n                }\n\n            });\n\n            // Detect infinite loops of mimic joints\n            jointList.forEach(j => {\n\n                const uniqueJoints = new Set();\n                const iterFunction = joint => {\n\n                    if (uniqueJoints.has(joint)) {\n\n                        throw new Error('URDFLoader: Detected an infinite loop of mimic joints.');\n\n                    }\n\n                    uniqueJoints.add(joint);\n                    joint.mimicJoints.forEach(j => {\n\n                        iterFunction(j);\n\n                    });\n\n                };\n\n                iterFunction(j);\n            });\n\n            obj.frames = {\n                ...colliderMap,\n                ...visualMap,\n                ...linkMap,\n                ...jointMap,\n            };\n\n            return obj;\n\n        }\n\n        // Process joint nodes and parent them\n        function processJoint(joint) {\n\n            const children = [ ...joint.children ];\n            const jointType = joint.getAttribute('type');\n\n            let obj;\n\n            const mimicTag = children.find(n => n.nodeName.toLowerCase() === 'mimic');\n            if (mimicTag) {\n\n                obj = new URDFMimicJoint();\n                obj.mimicJoint = mimicTag.getAttribute('joint');\n                obj.multiplier = parseFloat(mimicTag.getAttribute('multiplier') || 1.0);\n                obj.offset = parseFloat(mimicTag.getAttribute('offset') || 0.0);\n\n            } else {\n\n                obj = new URDFJoint();\n\n            }\n\n            obj.urdfNode = joint;\n            obj.name = joint.getAttribute('name');\n            obj.urdfName = obj.name;\n            obj.jointType = jointType;\n\n            let parent = null;\n            let child = null;\n            let xyz = [0, 0, 0];\n            let rpy = [0, 0, 0];\n\n            // Extract the attributes\n            children.forEach(n => {\n\n                const type = n.nodeName.toLowerCase();\n                if (type === 'origin') {\n\n                    xyz = processTuple(n.getAttribute('xyz'));\n                    rpy = processTuple(n.getAttribute('rpy'));\n\n                } else if (type === 'child') {\n\n                    child = linkMap[n.getAttribute('link')];\n\n                } else if (type === 'parent') {\n\n                    parent = linkMap[n.getAttribute('link')];\n\n                } else if (type === 'limit') {\n\n                    obj.limit.lower = parseFloat(n.getAttribute('lower') || obj.limit.lower);\n                    obj.limit.upper = parseFloat(n.getAttribute('upper') || obj.limit.upper);\n\n                }\n            });\n\n            // Join the links\n            parent.add(obj);\n            obj.add(child);\n            applyRotation(obj, rpy);\n            obj.position.set(xyz[0], xyz[1], xyz[2]);\n\n            // Set up the rotate function\n            const axisNode = children.filter(n => n.nodeName.toLowerCase() === 'axis')[0];\n\n            if (axisNode) {\n\n                const axisXYZ = axisNode.getAttribute('xyz').split(/\\s+/g).map(num => parseFloat(num));\n                obj.axis = new THREE.Vector3(axisXYZ[0], axisXYZ[1], axisXYZ[2]);\n                obj.axis.normalize();\n\n            }\n\n            return obj;\n\n        }\n\n        // Process the <link> nodes\n        function processLink(link, visualMap, colliderMap, target = null) {\n\n            if (target === null) {\n\n                target = new URDFLink();\n\n            }\n\n            const children = [ ...link.children ];\n            target.name = link.getAttribute('name');\n            target.urdfName = target.name;\n            target.urdfNode = link;\n\n            if (parseVisual) {\n\n                const visualNodes = children.filter(n => n.nodeName.toLowerCase() === 'visual');\n                visualNodes.forEach(vn => {\n\n                    const v = processLinkElement(vn, materialMap);\n                    target.add(v);\n\n                    if (vn.hasAttribute('name')) {\n\n                        const name = vn.getAttribute('name');\n                        v.name = name;\n                        v.urdfName = name;\n                        visualMap[name] = v;\n\n                    }\n\n                });\n\n            }\n\n            if (parseCollision) {\n\n                const collisionNodes = children.filter(n => n.nodeName.toLowerCase() === 'collision');\n                collisionNodes.forEach(cn => {\n\n                    const c = processLinkElement(cn);\n                    target.add(c);\n\n                    if (cn.hasAttribute('name')) {\n\n                        const name = cn.getAttribute('name');\n                        c.name = name;\n                        c.urdfName = name;\n                        colliderMap[name] = c;\n\n                    }\n\n                });\n\n            }\n\n            return target;\n\n        }\n\n        function processMaterial(node) {\n\n            const matNodes = [ ...node.children ];\n            const material = new THREE.MeshPhongMaterial();\n\n            material.name = node.getAttribute('name') || '';\n            matNodes.forEach(n => {\n\n                const type = n.nodeName.toLowerCase();\n                if (type === 'color') {\n\n                    const rgba =\n                        n\n                            .getAttribute('rgba')\n                            .split(/\\s/g)\n                            .map(v => parseFloat(v));\n\n                    material.color.setRGB(rgba[0], rgba[1], rgba[2]).convertSRGBToLinear();\n                    material.opacity = rgba[3];\n                    material.transparent = rgba[3] < 1;\n                    material.depthWrite = !material.transparent;\n\n                } else if (type === 'texture') {\n\n                    // The URDF spec does not require that the <texture/> tag include\n                    // a filename attribute so skip loading the texture if not provided.\n                    const filename = n.getAttribute('filename');\n                    if (filename) {\n\n                        const loader = new THREE.TextureLoader(manager);\n                        const filePath = resolvePath(filename);\n                        material.map = loader.load(filePath);\n                        material.map.encoding = THREE.sRGBEncoding;\n\n                    }\n\n                }\n            });\n\n            return material;\n\n        }\n\n        // Process the visual and collision nodes into meshes\n        function processLinkElement(vn, materialMap = {}) {\n\n            const isCollisionNode = vn.nodeName.toLowerCase() === 'collision';\n            const children = [ ...vn.children ];\n            let material = null;\n\n            // get the material first\n            const materialNode = children.filter(n => n.nodeName.toLowerCase() === 'material')[0];\n            if (materialNode) {\n\n                const name = materialNode.getAttribute('name');\n                if (name && name in materialMap) {\n\n                    material = materialMap[name];\n\n                } else {\n\n                    material = processMaterial(materialNode);\n\n                }\n\n            } else {\n\n                material = new THREE.MeshPhongMaterial();\n\n            }\n\n            const group = isCollisionNode ? new URDFCollider() : new URDFVisual();\n            group.urdfNode = vn;\n\n            children.forEach(n => {\n\n                const type = n.nodeName.toLowerCase();\n                if (type === 'geometry') {\n\n                    const geoType = n.children[0].nodeName.toLowerCase();\n                    if (geoType === 'mesh') {\n\n                        const filename = n.children[0].getAttribute('filename');\n                        const filePath = resolvePath(filename);\n\n                        // file path is null if a package directory is not provided.\n                        if (filePath !== null) {\n\n                            const scaleAttr = n.children[0].getAttribute('scale');\n                            if (scaleAttr) {\n\n                                const scale = processTuple(scaleAttr);\n                                group.scale.set(scale[0], scale[1], scale[2]);\n\n                            }\n\n                            loadMeshCb(filePath, manager, (obj, err) => {\n\n                                if (err) {\n\n                                    console.error('URDFLoader: Error loading mesh.', err);\n\n                                } else if (obj) {\n\n                                    if (obj instanceof THREE.Mesh) {\n\n                                        obj.material = material;\n\n                                    }\n\n                                    // We don't expect non identity rotations or positions. In the case of\n                                    // COLLADA files the model might come in with a custom scale for unit\n                                    // conversion.\n                                    obj.position.set(0, 0, 0);\n                                    obj.quaternion.identity();\n                                    group.add(obj);\n\n                                }\n\n                            });\n\n                        }\n\n                    } else if (geoType === 'box') {\n\n                        const primitiveModel = new THREE.Mesh();\n                        primitiveModel.geometry = new THREE.BoxBufferGeometry(1, 1, 1);\n                        primitiveModel.material = material;\n\n                        const size = processTuple(n.children[0].getAttribute('size'));\n                        primitiveModel.scale.set(size[0], size[1], size[2]);\n\n                        group.add(primitiveModel);\n\n                    } else if (geoType === 'sphere') {\n\n                        const primitiveModel = new THREE.Mesh();\n                        primitiveModel.geometry = new THREE.SphereBufferGeometry(1, 30, 30);\n                        primitiveModel.material = material;\n\n                        const radius = parseFloat(n.children[0].getAttribute('radius')) || 0;\n                        primitiveModel.scale.set(radius, radius, radius);\n\n                        group.add(primitiveModel);\n\n                    } else if (geoType === 'cylinder') {\n\n                        const primitiveModel = new THREE.Mesh();\n                        primitiveModel.geometry = new THREE.CylinderBufferGeometry(1, 1, 1, 30);\n                        primitiveModel.material = material;\n\n                        const radius = parseFloat(n.children[0].getAttribute('radius')) || 0;\n                        const length = parseFloat(n.children[0].getAttribute('length')) || 0;\n                        primitiveModel.scale.set(radius, length, radius);\n                        primitiveModel.rotation.set(Math.PI / 2, 0, 0);\n\n                        group.add(primitiveModel);\n\n                    }\n\n                } else if (type === 'origin') {\n\n                    const xyz = processTuple(n.getAttribute('xyz'));\n                    const rpy = processTuple(n.getAttribute('rpy'));\n\n                    group.position.set(xyz[0], xyz[1], xyz[2]);\n                    group.rotation.set(0, 0, 0);\n                    applyRotation(group, rpy);\n\n                }\n\n            });\n\n            return group;\n\n        }\n\n        return processUrdf(content);\n\n    }\n\n    // Default mesh loading function\n    defaultMeshLoader(path, manager, done) {\n\n        if (/\\.stl$/i.test(path)) {\n\n            const loader = new STLLoader(manager);\n            loader.load(path, geom => {\n                const mesh = new THREE.Mesh(geom, new THREE.MeshPhongMaterial());\n                done(mesh);\n            });\n\n        } else if (/\\.dae$/i.test(path)) {\n\n            const loader = new ColladaLoader(manager);\n            loader.load(path, dae => done(dae.scene));\n\n        } else {\n\n            console.warn(`URDFLoader: Could not load model at ${ path }.\\nNo loader available`);\n\n        }\n\n    }\n\n};\n"],"mappings":"AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAC9B,SAASC,SAAS,QAAQ,yCAAyC;AACnE,SAASC,aAAa,QAAQ,6CAA6C;AAC3E,SAASC,SAAS,EAAEC,SAAS,EAAEC,QAAQ,EAAEC,YAAY,EAAEC,UAAU,EAAEC,cAAc,QAAQ,kBAAkB;;AAE3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMC,cAAc,GAAG,IAAIT,KAAK,CAACU,UAAU,EAAE;AAC7C,MAAMC,SAAS,GAAG,IAAIX,KAAK,CAACY,KAAK,EAAE;;AAEnC;AACA;AACA,SAASC,YAAYA,CAACC,GAAG,EAAE;EAEvB,IAAI,CAACA,GAAG,EAAE,OAAO,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EAC1B,OAAOA,GAAG,CAACC,IAAI,EAAE,CAACC,KAAK,CAAC,MAAM,CAAC,CAACC,GAAG,CAACC,GAAG,IAAIC,UAAU,CAACD,GAAG,CAAC,CAAC;AAE/D;;AAEA;AACA,SAASE,aAAaA,CAACC,GAAG,EAAEC,GAAG,EAAoB;EAAA,IAAlBC,QAAQ,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,KAAK;EAE7C;EACA;EACA,IAAI,CAACD,QAAQ,EAAEF,GAAG,CAACM,QAAQ,CAACC,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;EAExCjB,SAAS,CAACiB,GAAG,CAACN,GAAG,CAAC,CAAC,CAAC,EAAEA,GAAG,CAAC,CAAC,CAAC,EAAEA,GAAG,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC;EAC5Cb,cAAc,CAACoB,YAAY,CAAClB,SAAS,CAAC;EACtCF,cAAc,CAACqB,QAAQ,CAACT,GAAG,CAACU,UAAU,CAAC;EACvCV,GAAG,CAACU,UAAU,CAACC,IAAI,CAACvB,cAAc,CAAC;AAEvC;;AAEA;AACA;AACA,eACA,MAAMwB,UAAU,CAAC;EAEbC,WAAWA,CAACC,OAAO,EAAE;IAEjB,IAAI,CAACA,OAAO,GAAGA,OAAO,IAAInC,KAAK,CAACoC,qBAAqB;IACrD,IAAI,CAACC,UAAU,GAAG,IAAI,CAACC,iBAAiB,CAACC,IAAI,CAAC,IAAI,CAAC;IACnD,IAAI,CAACC,WAAW,GAAG,IAAI;IACvB,IAAI,CAACC,cAAc,GAAG,KAAK;IAC3B,IAAI,CAACC,QAAQ,GAAG,EAAE;IAClB,IAAI,CAACC,WAAW,GAAG,EAAE;IACrB,IAAI,CAACC,YAAY,GAAG,CAAC,CAAC;EAE1B;;EAEA;EACAC,SAASA,CAACC,IAAI,EAAE;IAEZ,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MAEpC,IAAI,CAACC,IAAI,CAACJ,IAAI,EAAEE,OAAO,EAAE,IAAI,EAAEC,MAAM,CAAC;IAE1C,CAAC,CAAC;EAEN;;EAEA;EACA;EACAC,IAAIA,CAACJ,IAAI,EAAEK,UAAU,EAAEC,UAAU,EAAEC,OAAO,EAAE;IAExC;IACA;IACA,MAAMlB,OAAO,GAAG,IAAI,CAACA,OAAO;IAC5B,MAAMQ,WAAW,GAAG3C,KAAK,CAACsD,WAAW,CAACC,cAAc,CAACT,IAAI,CAAC;IAC1D,MAAMU,QAAQ,GAAG,IAAI,CAACrB,OAAO,CAACsB,UAAU,CAACX,IAAI,CAAC;IAE9CX,OAAO,CAACuB,SAAS,CAACF,QAAQ,CAAC;IAE3BG,KAAK,CAACH,QAAQ,EAAE,IAAI,CAACZ,YAAY,CAAC,CAC7BgB,IAAI,CAACC,GAAG,IAAI;MAET,IAAIA,GAAG,CAACC,EAAE,EAAE;QAER,IAAIV,UAAU,EAAE;UAEZA,UAAU,CAAC,IAAI,CAAC;QAEpB;QACA,OAAOS,GAAG,CAACE,IAAI,EAAE;MAErB,CAAC,MAAM;QAEH,MAAM,IAAIC,KAAK,CAAE,mCAAmCR,QAAU,qBAAqBK,GAAG,CAACI,MAAQ,MAAMJ,GAAG,CAACK,UAAY,GAAE,CAAC;MAE5H;IAEJ,CAAC,CAAC,CACDN,IAAI,CAACO,IAAI,IAAI;MAEV,IAAI,IAAI,CAACxB,WAAW,KAAK,EAAE,EAAE;QAEzB,IAAI,CAACA,WAAW,GAAGA,WAAW;MAElC;MAEA,MAAMyB,KAAK,GAAG,IAAI,CAACC,KAAK,CAACF,IAAI,CAAC;MAC9BhB,UAAU,CAACiB,KAAK,CAAC;MACjBjC,OAAO,CAACmC,OAAO,CAACd,QAAQ,CAAC;IAE7B,CAAC,CAAC,CACDe,KAAK,CAACC,CAAC,IAAI;MAER,IAAInB,OAAO,EAAE;QAETA,OAAO,CAACmB,CAAC,CAAC;MAEd,CAAC,MAAM;QAEHC,OAAO,CAACC,KAAK,CAAC,iCAAiC,EAAEF,CAAC,CAAC;MAEvD;MACArC,OAAO,CAACwC,SAAS,CAACnB,QAAQ,CAAC;MAC3BrB,OAAO,CAACmC,OAAO,CAACd,QAAQ,CAAC;IAE7B,CAAC,CAAC;EAEV;EAEAa,KAAKA,CAACO,OAAO,EAAE;IAEX,MAAMlC,QAAQ,GAAG,IAAI,CAACA,QAAQ;IAC9B,MAAML,UAAU,GAAG,IAAI,CAACA,UAAU;IAClC,MAAMG,WAAW,GAAG,IAAI,CAACA,WAAW;IACpC,MAAMC,cAAc,GAAG,IAAI,CAACA,cAAc;IAC1C,MAAME,WAAW,GAAG,IAAI,CAACA,WAAW;IACpC,MAAMR,OAAO,GAAG,IAAI,CAACA,OAAO;IAC5B,MAAM0C,OAAO,GAAG,CAAC,CAAC;IAClB,MAAMC,QAAQ,GAAG,CAAC,CAAC;IACnB,MAAMC,WAAW,GAAG,CAAC,CAAC;;IAEtB;IACA,SAASC,WAAWA,CAACC,IAAI,EAAE;MAEvB,IAAI,CAAC,eAAe,CAACC,IAAI,CAACD,IAAI,CAAC,EAAE;QAE7B,OAAOtC,WAAW,GAAGA,WAAW,GAAGsC,IAAI,GAAGA,IAAI;MAElD;;MAEA;MACA,MAAM,CAACE,SAAS,EAAEC,OAAO,CAAC,GAAGH,IAAI,CAACI,OAAO,CAAC,eAAe,EAAE,EAAE,CAAC,CAACrE,KAAK,CAAC,QAAQ,CAAC;MAE9E,IAAI,OAAO0B,QAAQ,KAAK,QAAQ,EAAE;QAE9B;QACA,IAAIA,QAAQ,CAAC4C,QAAQ,CAACH,SAAS,CAAC,EAAE;UAE9B;UACA,OAAOzC,QAAQ,GAAG,GAAG,GAAG0C,OAAO;QAEnC,CAAC,MAAM;UAEH;UACA,OAAO1C,QAAQ,GAAG,GAAG,GAAGyC,SAAS,GAAG,GAAG,GAAGC,OAAO;QAErD;MAEJ,CAAC,MAAM,IAAI1C,QAAQ,YAAY6C,QAAQ,EAAE;QAErC,OAAO7C,QAAQ,CAACyC,SAAS,CAAC,GAAG,GAAG,GAAGC,OAAO;MAE9C,CAAC,MAAM,IAAI,OAAO1C,QAAQ,KAAK,QAAQ,EAAE;QAErC;QACA,IAAIyC,SAAS,IAAIzC,QAAQ,EAAE;UAEvB,OAAOA,QAAQ,CAACyC,SAAS,CAAC,GAAG,GAAG,GAAGC,OAAO;QAE9C,CAAC,MAAM;UAEHX,OAAO,CAACC,KAAK,CAAE,gBAAgBS,SAAW,sCAAqC,CAAC;UAChF,OAAO,IAAI;QAEf;MAEJ;IAEJ;;IAEA;IACA,SAASK,WAAWA,CAACrB,IAAI,EAAE;MAEvB,IAAIsB,QAAQ;MACZ,IAAItB,IAAI,YAAYuB,QAAQ,EAAE;QAE1BD,QAAQ,GAAG,CAAE,GAAGtB,IAAI,CAACsB,QAAQ,CAAE;MAEnC,CAAC,MAAM,IAAItB,IAAI,YAAYwB,OAAO,EAAE;QAEhCF,QAAQ,GAAG,CAAEtB,IAAI,CAAE;MAEvB,CAAC,MAAM;QAEH,MAAMyB,MAAM,GAAG,IAAIC,SAAS,EAAE;QAC9B,MAAM/C,IAAI,GAAG8C,MAAM,CAACE,eAAe,CAAC3B,IAAI,EAAE,UAAU,CAAC;QACrDsB,QAAQ,GAAG,CAAE,GAAG3C,IAAI,CAAC2C,QAAQ,CAAE;MAEnC;MAEA,MAAMM,SAAS,GAAGN,QAAQ,CAACO,MAAM,CAACC,CAAC,IAAIA,CAAC,CAACC,QAAQ,KAAK,OAAO,CAAC,CAACC,GAAG,EAAE;MACpE,OAAOC,YAAY,CAACL,SAAS,CAAC;IAElC;;IAEA;IACA,SAASK,YAAYA,CAACC,KAAK,EAAE;MAEzB,MAAMC,UAAU,GAAG,CAAE,GAAGD,KAAK,CAACZ,QAAQ,CAAE;MACxC,MAAMc,KAAK,GAAGD,UAAU,CAACN,MAAM,CAACC,CAAC,IAAIA,CAAC,CAACC,QAAQ,CAACM,WAAW,EAAE,KAAK,MAAM,CAAC;MACzE,MAAMC,MAAM,GAAGH,UAAU,CAACN,MAAM,CAACC,CAAC,IAAIA,CAAC,CAACC,QAAQ,CAACM,WAAW,EAAE,KAAK,OAAO,CAAC;MAC3E,MAAME,SAAS,GAAGJ,UAAU,CAACN,MAAM,CAACC,CAAC,IAAIA,CAAC,CAACC,QAAQ,CAACM,WAAW,EAAE,KAAK,UAAU,CAAC;MACjF,MAAMnF,GAAG,GAAG,IAAIlB,SAAS,EAAE;MAE3BkB,GAAG,CAACsF,SAAS,GAAGN,KAAK,CAACO,YAAY,CAAC,MAAM,CAAC;MAC1CvF,GAAG,CAACwF,aAAa,GAAGR,KAAK;;MAEzB;MACAK,SAAS,CAACI,OAAO,CAACC,CAAC,IAAI;QAEnB,MAAMC,IAAI,GAAGD,CAAC,CAACH,YAAY,CAAC,MAAM,CAAC;QACnC7B,WAAW,CAACiC,IAAI,CAAC,GAAGC,eAAe,CAACF,CAAC,CAAC;MAE1C,CAAC,CAAC;;MAEF;MACA,MAAMG,SAAS,GAAG,CAAC,CAAC;MACpB,MAAMC,WAAW,GAAG,CAAC,CAAC;MACtBZ,KAAK,CAACO,OAAO,CAACM,CAAC,IAAI;QAEf,MAAMJ,IAAI,GAAGI,CAAC,CAACR,YAAY,CAAC,MAAM,CAAC;QACnC,MAAMS,MAAM,GAAGhB,KAAK,CAACiB,aAAa,CAAE,eAAeN,IAAM,IAAG,CAAC,KAAK,IAAI;QACtEnC,OAAO,CAACmC,IAAI,CAAC,GAAGO,WAAW,CAACH,CAAC,EAAEF,SAAS,EAAEC,WAAW,EAAEE,MAAM,GAAGhG,GAAG,GAAG,IAAI,CAAC;MAE/E,CAAC,CAAC;;MAEF;MACAoF,MAAM,CAACK,OAAO,CAACU,CAAC,IAAI;QAEhB,MAAMR,IAAI,GAAGQ,CAAC,CAACZ,YAAY,CAAC,MAAM,CAAC;QACnC9B,QAAQ,CAACkC,IAAI,CAAC,GAAGS,YAAY,CAACD,CAAC,CAAC;MAEpC,CAAC,CAAC;MAEFnG,GAAG,CAACoF,MAAM,GAAG3B,QAAQ;MACrBzD,GAAG,CAACkF,KAAK,GAAG1B,OAAO;MACnBxD,GAAG,CAACqG,SAAS,GAAGP,WAAW;MAC3B9F,GAAG,CAACsG,MAAM,GAAGT,SAAS;;MAEtB;MACA,MAAMU,SAAS,GAAGC,MAAM,CAACC,MAAM,CAAChD,QAAQ,CAAC;MACzC8C,SAAS,CAACd,OAAO,CAACU,CAAC,IAAI;QAEnB,IAAIA,CAAC,YAAYhH,cAAc,EAAE;UAE7BsE,QAAQ,CAAC0C,CAAC,CAACO,UAAU,CAAC,CAACC,WAAW,CAACC,IAAI,CAACT,CAAC,CAAC;QAE9C;MAEJ,CAAC,CAAC;;MAEF;MACAI,SAAS,CAACd,OAAO,CAACU,CAAC,IAAI;QAEnB,MAAMU,YAAY,GAAG,IAAIC,GAAG,EAAE;QAC9B,MAAMC,YAAY,GAAGC,KAAK,IAAI;UAE1B,IAAIH,YAAY,CAACI,GAAG,CAACD,KAAK,CAAC,EAAE;YAEzB,MAAM,IAAIrE,KAAK,CAAC,wDAAwD,CAAC;UAE7E;UAEAkE,YAAY,CAACK,GAAG,CAACF,KAAK,CAAC;UACvBA,KAAK,CAACL,WAAW,CAAClB,OAAO,CAACU,CAAC,IAAI;YAE3BY,YAAY,CAACZ,CAAC,CAAC;UAEnB,CAAC,CAAC;QAEN,CAAC;QAEDY,YAAY,CAACZ,CAAC,CAAC;MACnB,CAAC,CAAC;MAEFnG,GAAG,CAACmH,MAAM,GAAG;QACT,GAAGrB,WAAW;QACd,GAAGD,SAAS;QACZ,GAAGrC,OAAO;QACV,GAAGC;MACP,CAAC;MAED,OAAOzD,GAAG;IAEd;;IAEA;IACA,SAASoG,YAAYA,CAACY,KAAK,EAAE;MAEzB,MAAM5C,QAAQ,GAAG,CAAE,GAAG4C,KAAK,CAAC5C,QAAQ,CAAE;MACtC,MAAMgD,SAAS,GAAGJ,KAAK,CAACzB,YAAY,CAAC,MAAM,CAAC;MAE5C,IAAIvF,GAAG;MAEP,MAAMqH,QAAQ,GAAGjD,QAAQ,CAACkD,IAAI,CAACC,CAAC,IAAIA,CAAC,CAAC1C,QAAQ,CAACM,WAAW,EAAE,KAAK,OAAO,CAAC;MACzE,IAAIkC,QAAQ,EAAE;QAEVrH,GAAG,GAAG,IAAIb,cAAc,EAAE;QAC1Ba,GAAG,CAAC0G,UAAU,GAAGW,QAAQ,CAAC9B,YAAY,CAAC,OAAO,CAAC;QAC/CvF,GAAG,CAACwH,UAAU,GAAG1H,UAAU,CAACuH,QAAQ,CAAC9B,YAAY,CAAC,YAAY,CAAC,IAAI,GAAG,CAAC;QACvEvF,GAAG,CAACyH,MAAM,GAAG3H,UAAU,CAACuH,QAAQ,CAAC9B,YAAY,CAAC,QAAQ,CAAC,IAAI,GAAG,CAAC;MAEnE,CAAC,MAAM;QAEHvF,GAAG,GAAG,IAAIjB,SAAS,EAAE;MAEzB;MAEAiB,GAAG,CAAC0H,QAAQ,GAAGV,KAAK;MACpBhH,GAAG,CAAC2F,IAAI,GAAGqB,KAAK,CAACzB,YAAY,CAAC,MAAM,CAAC;MACrCvF,GAAG,CAAC2H,QAAQ,GAAG3H,GAAG,CAAC2F,IAAI;MACvB3F,GAAG,CAACoH,SAAS,GAAGA,SAAS;MAEzB,IAAIQ,MAAM,GAAG,IAAI;MACjB,IAAIC,KAAK,GAAG,IAAI;MAChB,IAAIC,GAAG,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;MACnB,IAAI7H,GAAG,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;;MAEnB;MACAmE,QAAQ,CAACqB,OAAO,CAAC8B,CAAC,IAAI;QAElB,MAAMQ,IAAI,GAAGR,CAAC,CAAC1C,QAAQ,CAACM,WAAW,EAAE;QACrC,IAAI4C,IAAI,KAAK,QAAQ,EAAE;UAEnBD,GAAG,GAAGtI,YAAY,CAAC+H,CAAC,CAAChC,YAAY,CAAC,KAAK,CAAC,CAAC;UACzCtF,GAAG,GAAGT,YAAY,CAAC+H,CAAC,CAAChC,YAAY,CAAC,KAAK,CAAC,CAAC;QAE7C,CAAC,MAAM,IAAIwC,IAAI,KAAK,OAAO,EAAE;UAEzBF,KAAK,GAAGrE,OAAO,CAAC+D,CAAC,CAAChC,YAAY,CAAC,MAAM,CAAC,CAAC;QAE3C,CAAC,MAAM,IAAIwC,IAAI,KAAK,QAAQ,EAAE;UAE1BH,MAAM,GAAGpE,OAAO,CAAC+D,CAAC,CAAChC,YAAY,CAAC,MAAM,CAAC,CAAC;QAE5C,CAAC,MAAM,IAAIwC,IAAI,KAAK,OAAO,EAAE;UAEzB/H,GAAG,CAACgI,KAAK,CAACC,KAAK,GAAGnI,UAAU,CAACyH,CAAC,CAAChC,YAAY,CAAC,OAAO,CAAC,IAAIvF,GAAG,CAACgI,KAAK,CAACC,KAAK,CAAC;UACxEjI,GAAG,CAACgI,KAAK,CAACE,KAAK,GAAGpI,UAAU,CAACyH,CAAC,CAAChC,YAAY,CAAC,OAAO,CAAC,IAAIvF,GAAG,CAACgI,KAAK,CAACE,KAAK,CAAC;QAE5E;MACJ,CAAC,CAAC;;MAEF;MACAN,MAAM,CAACV,GAAG,CAAClH,GAAG,CAAC;MACfA,GAAG,CAACkH,GAAG,CAACW,KAAK,CAAC;MACd9H,aAAa,CAACC,GAAG,EAAEC,GAAG,CAAC;MACvBD,GAAG,CAACmI,QAAQ,CAAC5H,GAAG,CAACuH,GAAG,CAAC,CAAC,CAAC,EAAEA,GAAG,CAAC,CAAC,CAAC,EAAEA,GAAG,CAAC,CAAC,CAAC,CAAC;;MAExC;MACA,MAAMM,QAAQ,GAAGhE,QAAQ,CAACO,MAAM,CAAC4C,CAAC,IAAIA,CAAC,CAAC1C,QAAQ,CAACM,WAAW,EAAE,KAAK,MAAM,CAAC,CAAC,CAAC,CAAC;MAE7E,IAAIiD,QAAQ,EAAE;QAEV,MAAMC,OAAO,GAAGD,QAAQ,CAAC7C,YAAY,CAAC,KAAK,CAAC,CAAC5F,KAAK,CAAC,MAAM,CAAC,CAACC,GAAG,CAACC,GAAG,IAAIC,UAAU,CAACD,GAAG,CAAC,CAAC;QACtFG,GAAG,CAACsI,IAAI,GAAG,IAAI3J,KAAK,CAAC4J,OAAO,CAACF,OAAO,CAAC,CAAC,CAAC,EAAEA,OAAO,CAAC,CAAC,CAAC,EAAEA,OAAO,CAAC,CAAC,CAAC,CAAC;QAChErI,GAAG,CAACsI,IAAI,CAACE,SAAS,EAAE;MAExB;MAEA,OAAOxI,GAAG;IAEd;;IAEA;IACA,SAASkG,WAAWA,CAACuC,IAAI,EAAE5C,SAAS,EAAEC,WAAW,EAAiB;MAAA,IAAf4C,MAAM,GAAAvI,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,IAAI;MAE5D,IAAIuI,MAAM,KAAK,IAAI,EAAE;QAEjBA,MAAM,GAAG,IAAI1J,QAAQ,EAAE;MAE3B;MAEA,MAAMoF,QAAQ,GAAG,CAAE,GAAGqE,IAAI,CAACrE,QAAQ,CAAE;MACrCsE,MAAM,CAAC/C,IAAI,GAAG8C,IAAI,CAAClD,YAAY,CAAC,MAAM,CAAC;MACvCmD,MAAM,CAACf,QAAQ,GAAGe,MAAM,CAAC/C,IAAI;MAC7B+C,MAAM,CAAChB,QAAQ,GAAGe,IAAI;MAEtB,IAAItH,WAAW,EAAE;QAEb,MAAMwH,WAAW,GAAGvE,QAAQ,CAACO,MAAM,CAAC4C,CAAC,IAAIA,CAAC,CAAC1C,QAAQ,CAACM,WAAW,EAAE,KAAK,QAAQ,CAAC;QAC/EwD,WAAW,CAAClD,OAAO,CAACmD,EAAE,IAAI;UAEtB,MAAMC,CAAC,GAAGC,kBAAkB,CAACF,EAAE,EAAElF,WAAW,CAAC;UAC7CgF,MAAM,CAACxB,GAAG,CAAC2B,CAAC,CAAC;UAEb,IAAID,EAAE,CAACG,YAAY,CAAC,MAAM,CAAC,EAAE;YAEzB,MAAMpD,IAAI,GAAGiD,EAAE,CAACrD,YAAY,CAAC,MAAM,CAAC;YACpCsD,CAAC,CAAClD,IAAI,GAAGA,IAAI;YACbkD,CAAC,CAAClB,QAAQ,GAAGhC,IAAI;YACjBE,SAAS,CAACF,IAAI,CAAC,GAAGkD,CAAC;UAEvB;QAEJ,CAAC,CAAC;MAEN;MAEA,IAAIzH,cAAc,EAAE;QAEhB,MAAM4H,cAAc,GAAG5E,QAAQ,CAACO,MAAM,CAAC4C,CAAC,IAAIA,CAAC,CAAC1C,QAAQ,CAACM,WAAW,EAAE,KAAK,WAAW,CAAC;QACrF6D,cAAc,CAACvD,OAAO,CAACwD,EAAE,IAAI;UAEzB,MAAMrE,CAAC,GAAGkE,kBAAkB,CAACG,EAAE,CAAC;UAChCP,MAAM,CAACxB,GAAG,CAACtC,CAAC,CAAC;UAEb,IAAIqE,EAAE,CAACF,YAAY,CAAC,MAAM,CAAC,EAAE;YAEzB,MAAMpD,IAAI,GAAGsD,EAAE,CAAC1D,YAAY,CAAC,MAAM,CAAC;YACpCX,CAAC,CAACe,IAAI,GAAGA,IAAI;YACbf,CAAC,CAAC+C,QAAQ,GAAGhC,IAAI;YACjBG,WAAW,CAACH,IAAI,CAAC,GAAGf,CAAC;UAEzB;QAEJ,CAAC,CAAC;MAEN;MAEA,OAAO8D,MAAM;IAEjB;IAEA,SAAS9C,eAAeA,CAACsD,IAAI,EAAE;MAE3B,MAAMC,QAAQ,GAAG,CAAE,GAAGD,IAAI,CAAC9E,QAAQ,CAAE;MACrC,MAAMgF,QAAQ,GAAG,IAAIzK,KAAK,CAAC0K,iBAAiB,EAAE;MAE9CD,QAAQ,CAACzD,IAAI,GAAGuD,IAAI,CAAC3D,YAAY,CAAC,MAAM,CAAC,IAAI,EAAE;MAC/C4D,QAAQ,CAAC1D,OAAO,CAAC8B,CAAC,IAAI;QAElB,MAAMQ,IAAI,GAAGR,CAAC,CAAC1C,QAAQ,CAACM,WAAW,EAAE;QACrC,IAAI4C,IAAI,KAAK,OAAO,EAAE;UAElB,MAAMuB,IAAI,GACN/B,CAAC,CACIhC,YAAY,CAAC,MAAM,CAAC,CACpB5F,KAAK,CAAC,KAAK,CAAC,CACZC,GAAG,CAACiJ,CAAC,IAAI/I,UAAU,CAAC+I,CAAC,CAAC,CAAC;UAEhCO,QAAQ,CAACG,KAAK,CAACC,MAAM,CAACF,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,CAAC,CAACG,mBAAmB,EAAE;UACtEL,QAAQ,CAACM,OAAO,GAAGJ,IAAI,CAAC,CAAC,CAAC;UAC1BF,QAAQ,CAACO,WAAW,GAAGL,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC;UAClCF,QAAQ,CAACQ,UAAU,GAAG,CAACR,QAAQ,CAACO,WAAW;QAE/C,CAAC,MAAM,IAAI5B,IAAI,KAAK,SAAS,EAAE;UAE3B;UACA;UACA,MAAM8B,QAAQ,GAAGtC,CAAC,CAAChC,YAAY,CAAC,UAAU,CAAC;UAC3C,IAAIsE,QAAQ,EAAE;YAEV,MAAMC,MAAM,GAAG,IAAInL,KAAK,CAACoL,aAAa,CAACjJ,OAAO,CAAC;YAC/C,MAAMkJ,QAAQ,GAAGrG,WAAW,CAACkG,QAAQ,CAAC;YACtCT,QAAQ,CAACxJ,GAAG,GAAGkK,MAAM,CAACjI,IAAI,CAACmI,QAAQ,CAAC;YACpCZ,QAAQ,CAACxJ,GAAG,CAACqK,QAAQ,GAAGtL,KAAK,CAACuL,YAAY;UAE9C;QAEJ;MACJ,CAAC,CAAC;MAEF,OAAOd,QAAQ;IAEnB;;IAEA;IACA,SAASN,kBAAkBA,CAACF,EAAE,EAAoB;MAAA,IAAlBlF,WAAW,GAAAvD,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;MAE5C,MAAMgK,eAAe,GAAGvB,EAAE,CAAC/D,QAAQ,CAACM,WAAW,EAAE,KAAK,WAAW;MACjE,MAAMf,QAAQ,GAAG,CAAE,GAAGwE,EAAE,CAACxE,QAAQ,CAAE;MACnC,IAAIgF,QAAQ,GAAG,IAAI;;MAEnB;MACA,MAAMgB,YAAY,GAAGhG,QAAQ,CAACO,MAAM,CAAC4C,CAAC,IAAIA,CAAC,CAAC1C,QAAQ,CAACM,WAAW,EAAE,KAAK,UAAU,CAAC,CAAC,CAAC,CAAC;MACrF,IAAIiF,YAAY,EAAE;QAEd,MAAMzE,IAAI,GAAGyE,YAAY,CAAC7E,YAAY,CAAC,MAAM,CAAC;QAC9C,IAAII,IAAI,IAAIA,IAAI,IAAIjC,WAAW,EAAE;UAE7B0F,QAAQ,GAAG1F,WAAW,CAACiC,IAAI,CAAC;QAEhC,CAAC,MAAM;UAEHyD,QAAQ,GAAGxD,eAAe,CAACwE,YAAY,CAAC;QAE5C;MAEJ,CAAC,MAAM;QAEHhB,QAAQ,GAAG,IAAIzK,KAAK,CAAC0K,iBAAiB,EAAE;MAE5C;MAEA,MAAMgB,KAAK,GAAGF,eAAe,GAAG,IAAIlL,YAAY,EAAE,GAAG,IAAIC,UAAU,EAAE;MACrEmL,KAAK,CAAC3C,QAAQ,GAAGkB,EAAE;MAEnBxE,QAAQ,CAACqB,OAAO,CAAC8B,CAAC,IAAI;QAElB,MAAMQ,IAAI,GAAGR,CAAC,CAAC1C,QAAQ,CAACM,WAAW,EAAE;QACrC,IAAI4C,IAAI,KAAK,UAAU,EAAE;UAErB,MAAMuC,OAAO,GAAG/C,CAAC,CAACnD,QAAQ,CAAC,CAAC,CAAC,CAACS,QAAQ,CAACM,WAAW,EAAE;UACpD,IAAImF,OAAO,KAAK,MAAM,EAAE;YAEpB,MAAMT,QAAQ,GAAGtC,CAAC,CAACnD,QAAQ,CAAC,CAAC,CAAC,CAACmB,YAAY,CAAC,UAAU,CAAC;YACvD,MAAMyE,QAAQ,GAAGrG,WAAW,CAACkG,QAAQ,CAAC;;YAEtC;YACA,IAAIG,QAAQ,KAAK,IAAI,EAAE;cAEnB,MAAMO,SAAS,GAAGhD,CAAC,CAACnD,QAAQ,CAAC,CAAC,CAAC,CAACmB,YAAY,CAAC,OAAO,CAAC;cACrD,IAAIgF,SAAS,EAAE;gBAEX,MAAMC,KAAK,GAAGhL,YAAY,CAAC+K,SAAS,CAAC;gBACrCF,KAAK,CAACG,KAAK,CAACjK,GAAG,CAACiK,KAAK,CAAC,CAAC,CAAC,EAAEA,KAAK,CAAC,CAAC,CAAC,EAAEA,KAAK,CAAC,CAAC,CAAC,CAAC;cAEjD;cAEAxJ,UAAU,CAACgJ,QAAQ,EAAElJ,OAAO,EAAE,CAACd,GAAG,EAAEyK,GAAG,KAAK;gBAExC,IAAIA,GAAG,EAAE;kBAELrH,OAAO,CAACC,KAAK,CAAC,iCAAiC,EAAEoH,GAAG,CAAC;gBAEzD,CAAC,MAAM,IAAIzK,GAAG,EAAE;kBAEZ,IAAIA,GAAG,YAAYrB,KAAK,CAAC+L,IAAI,EAAE;oBAE3B1K,GAAG,CAACoJ,QAAQ,GAAGA,QAAQ;kBAE3B;;kBAEA;kBACA;kBACA;kBACApJ,GAAG,CAACmI,QAAQ,CAAC5H,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;kBACzBP,GAAG,CAACU,UAAU,CAACiK,QAAQ,EAAE;kBACzBN,KAAK,CAACnD,GAAG,CAAClH,GAAG,CAAC;gBAElB;cAEJ,CAAC,CAAC;YAEN;UAEJ,CAAC,MAAM,IAAIsK,OAAO,KAAK,KAAK,EAAE;YAE1B,MAAMM,cAAc,GAAG,IAAIjM,KAAK,CAAC+L,IAAI,EAAE;YACvCE,cAAc,CAACC,QAAQ,GAAG,IAAIlM,KAAK,CAACmM,iBAAiB,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;YAC9DF,cAAc,CAACxB,QAAQ,GAAGA,QAAQ;YAElC,MAAM2B,IAAI,GAAGvL,YAAY,CAAC+H,CAAC,CAACnD,QAAQ,CAAC,CAAC,CAAC,CAACmB,YAAY,CAAC,MAAM,CAAC,CAAC;YAC7DqF,cAAc,CAACJ,KAAK,CAACjK,GAAG,CAACwK,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,CAAC;YAEnDV,KAAK,CAACnD,GAAG,CAAC0D,cAAc,CAAC;UAE7B,CAAC,MAAM,IAAIN,OAAO,KAAK,QAAQ,EAAE;YAE7B,MAAMM,cAAc,GAAG,IAAIjM,KAAK,CAAC+L,IAAI,EAAE;YACvCE,cAAc,CAACC,QAAQ,GAAG,IAAIlM,KAAK,CAACqM,oBAAoB,CAAC,CAAC,EAAE,EAAE,EAAE,EAAE,CAAC;YACnEJ,cAAc,CAACxB,QAAQ,GAAGA,QAAQ;YAElC,MAAM6B,MAAM,GAAGnL,UAAU,CAACyH,CAAC,CAACnD,QAAQ,CAAC,CAAC,CAAC,CAACmB,YAAY,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC;YACpEqF,cAAc,CAACJ,KAAK,CAACjK,GAAG,CAAC0K,MAAM,EAAEA,MAAM,EAAEA,MAAM,CAAC;YAEhDZ,KAAK,CAACnD,GAAG,CAAC0D,cAAc,CAAC;UAE7B,CAAC,MAAM,IAAIN,OAAO,KAAK,UAAU,EAAE;YAE/B,MAAMM,cAAc,GAAG,IAAIjM,KAAK,CAAC+L,IAAI,EAAE;YACvCE,cAAc,CAACC,QAAQ,GAAG,IAAIlM,KAAK,CAACuM,sBAAsB,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;YACvEN,cAAc,CAACxB,QAAQ,GAAGA,QAAQ;YAElC,MAAM6B,MAAM,GAAGnL,UAAU,CAACyH,CAAC,CAACnD,QAAQ,CAAC,CAAC,CAAC,CAACmB,YAAY,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC;YACpE,MAAMnF,MAAM,GAAGN,UAAU,CAACyH,CAAC,CAACnD,QAAQ,CAAC,CAAC,CAAC,CAACmB,YAAY,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC;YACpEqF,cAAc,CAACJ,KAAK,CAACjK,GAAG,CAAC0K,MAAM,EAAE7K,MAAM,EAAE6K,MAAM,CAAC;YAChDL,cAAc,CAACtK,QAAQ,CAACC,GAAG,CAAC4K,IAAI,CAACC,EAAE,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;YAE9Cf,KAAK,CAACnD,GAAG,CAAC0D,cAAc,CAAC;UAE7B;QAEJ,CAAC,MAAM,IAAI7C,IAAI,KAAK,QAAQ,EAAE;UAE1B,MAAMD,GAAG,GAAGtI,YAAY,CAAC+H,CAAC,CAAChC,YAAY,CAAC,KAAK,CAAC,CAAC;UAC/C,MAAMtF,GAAG,GAAGT,YAAY,CAAC+H,CAAC,CAAChC,YAAY,CAAC,KAAK,CAAC,CAAC;UAE/C8E,KAAK,CAAClC,QAAQ,CAAC5H,GAAG,CAACuH,GAAG,CAAC,CAAC,CAAC,EAAEA,GAAG,CAAC,CAAC,CAAC,EAAEA,GAAG,CAAC,CAAC,CAAC,CAAC;UAC1CuC,KAAK,CAAC/J,QAAQ,CAACC,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;UAC3BR,aAAa,CAACsK,KAAK,EAAEpK,GAAG,CAAC;QAE7B;MAEJ,CAAC,CAAC;MAEF,OAAOoK,KAAK;IAEhB;IAEA,OAAOlG,WAAW,CAACZ,OAAO,CAAC;EAE/B;;EAEA;EACAtC,iBAAiBA,CAAC2C,IAAI,EAAE9C,OAAO,EAAEuK,IAAI,EAAE;IAEnC,IAAI,SAAS,CAACxH,IAAI,CAACD,IAAI,CAAC,EAAE;MAEtB,MAAMkG,MAAM,GAAG,IAAIlL,SAAS,CAACkC,OAAO,CAAC;MACrCgJ,MAAM,CAACjI,IAAI,CAAC+B,IAAI,EAAE0H,IAAI,IAAI;QACtB,MAAMC,IAAI,GAAG,IAAI5M,KAAK,CAAC+L,IAAI,CAACY,IAAI,EAAE,IAAI3M,KAAK,CAAC0K,iBAAiB,EAAE,CAAC;QAChEgC,IAAI,CAACE,IAAI,CAAC;MACd,CAAC,CAAC;IAEN,CAAC,MAAM,IAAI,SAAS,CAAC1H,IAAI,CAACD,IAAI,CAAC,EAAE;MAE7B,MAAMkG,MAAM,GAAG,IAAIjL,aAAa,CAACiC,OAAO,CAAC;MACzCgJ,MAAM,CAACjI,IAAI,CAAC+B,IAAI,EAAE4H,GAAG,IAAIH,IAAI,CAACG,GAAG,CAACC,KAAK,CAAC,CAAC;IAE7C,CAAC,MAAM;MAEHrI,OAAO,CAACsI,IAAI,CAAE,uCAAuC9H,IAAM,wBAAuB,CAAC;IAEvF;EAEJ;AAEJ;AAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}